---
title: "Indicators calculation functions"
output: html_document
editor_options: 
  chunk_output_type: console
---

<!-- Run this 'development' chunk -->
<!-- Store every call to library() that you need to explore your functions -->

```{r development, include=FALSE}
library(testthat)
```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

# Data Wrangling

Each indicator calculation is based on predefined frame, variable name and variable value.

Therefore each indicator function is organised in 3  steps:

 * Check if the standard frame/variable/modalities are already present in the dataset (organised as a list..) `fct_check_map`
 
 * If not apply the mapping supplied as argument within the function `fct_re_map`
 
 * Apply the calculation - either to append the new variable to the existing data or to output just the final vector with results. 
 
## fct_check_map

```{r function-fct_check_map}
#' fct_check_map
#' 
#' This check is the standard variable and modalities
#' 
#' @param datalist A list with all hierarchical data frame for a survey data set.
#'    format is expected to match the Excel export synchronized from kobo to RILD
#'    and loaded with  kobocruncher::kobo_data() 
#'                    
#' @param mapper a list providing the mapping of the variables used for the 
#' calculation - this mapper is potentially to be adjusted in relation with deviation
#' between the the standard XlsForm and the contextualized dataset
#' 
#' 
#' @return TRUE or FALSE
#' 
#' @export
fct_check_map <- function(datalist, mapper){

   ## Loop around the variables within mapper
   for ( i in 1:nrow(mapper[["variablemap"]]) ) {
     # i <- 1
     thisvar <-  mapper[["variablemap"]][["variable"]][[i]]
    if ( is.null(datalist[[mapper[["hierarchy"]] ]] [[ thisvar ]]) ) 
    {cli::cli_alert_info(paste0( thisvar ," standard variable was not found in the dataset.\n"))
      }
     else {
       ## If present check modalities
       mod <- mapper[["modalitymap"]] |>
         dplyr::filter( variable == thisvar ) |>
         dplyr::pull(standard)
      
      if( any(levels(as.factor(datalist[[mapper[["hierarchy"]] ]] [[ thisvar ]])) %in%  mod ) )
           { cat(paste0( thisvar ," is in the dataset and has at least one of the expected modality for calculation\n")) } else {
            cli::cli_alert_info(paste0( thisvar ,
                  " standard variable in the dataset misses at least one response among : ",
                                    mod))  }
     }
   }
}
```
  
```{r example-fct_check_map}

mapper = list(
            hierarchy = "main",
            variablemap = data.frame(
              label = c("Does this household use anything for lighting?",
                        "What source of electricity is used most of the time in this household?"),
              variable = c("LIGHT01", 
                           "LIGHT03"),
              mappattern = c("LIGHT01", 
                           "LIGHT03") ),
            modalitymap = data.frame(
              variable = c( "LIGHT01", 
                            "LIGHT03", "LIGHT03", "LIGHT03"),
              label = c( "yes",
                        "No electricity in household", "Other, specify", "Don't know"),
              standard = c( "1",
                           "1", "96", "98"),
              map = c("1",
                      "1", "96", "98")
            )
          )

## Correct format
data <- list(main = data.frame(
                LIGHT01 = c("1",  "1",  "0", "1",  "1",  "0", "1",  "1",  "1"),
                LIGHT03 = c("1", "96", "98", "1", "96", "98", "0", "96", "98"))
             )
fct_check_map(datalist = data, mapper = mapper )

## One variable is not correctly 
data <- list(main = data.frame(
                LIGHT01 = c("1",  "1",  "0", "1",  "1",  "0", "1",  "1",  "1"),
                LIGH03 = c("1", "96", "98", "1", "96", "98", "0", "96", "98"))
             )
fct_check_map(datalist = data, mapper = mapper )

## The first variable does not include a single 1...
data <- list(main = data.frame(
                LIGHT01 = c("0",  "0",  "0", "0",  "0",  "0", "0",  "0",  "0"),
                LIGHT03 = c("1", "96", "98", "1", "96", "98", "0", "96", "98"))
             )
fct_check_map(datalist = data, mapper = mapper )


```
  
```{r tests-fct_check_map}
test_that("fct_check_map works", {
  expect_true(inherits(fct_check_map, "function")) 
})
```
  
   

## fct_get_all_variable_names
    
```{r function-fct_get_all_variable_names}
#' fct_get_all_variable_names
#' 
#' Generate a map of all variables within the datalist obtained from RIDL - 
#'   standard Kobo extract in Excel
#' 
#' @param datalist A list with all hierarchical data frame for a survey data set.
#'    format is expected to match the Excel export synchronized from kobo to RILD
#'    and loaded with  kobocruncher::kobo_data() 
#' 
#' @return dataframe with variables and list member names 
#' 
#' @importFrom purrr imap list_rbind
#' @importFrom tibble tibble as_tibble_col
#' @importFrom tidyr unnest
#' 
#' @export
fct_get_all_variable_names <- function(datalist){
  
    dico <- purrr::imap(datalist,
       function(x, y) tibble::tibble(df = y,
                      vars = tibble::as_tibble_col(names(x))) |> 
         tidyr::unnest(vars)) |>
       purrr::list_rbind()
    
    return(dico)
    
}
```
  
```{r example-fct_get_all_variable_names}
data <- kobocruncher::kobo_data( here::here("data-raw", "data2.xlsx"))
varname <-   fct_get_all_variable_names(datalist = data)
head(varname, 10)
```
  
```{r tests-fct_get_all_variable_names}
test_that("fct_get_all_variable_names works", {
  expect_true(inherits(fct_get_all_variable_names, "function")) 
})
```



## fct_re_map
    
```{r function-fct_re_map}
#' fct_re_map
#' 
#' Take a list with a hierarchical survey as an entry - use another list to remap
#' variables and modalities for specific questions 
#' @param datalist A list with all hierarchical data frame for a survey data set.
#'    format is expected to match the Excel export synchronized from kobo to RILD
#'    and loaded with  kobocruncher::kobo_data() 
#'                    
#' @param mapper a list providing the mapping of the variables used for the 
#' calculation - this mapper is potentially to be adjusted in relation with deviation
#' between the the standard XlsForm and the contextualized dataset
#' 
#' @importFrom dplyr filter row_number mutate pull
#' @importFrom cli cli_alert_info
#' @return datalist
#' 
#' @export
fct_re_map <- function(datalist, mapper){
  
   varname <-   fct_get_all_variable_names(datalist)
   ## Loop around the variables within mapper
   for ( i in 1:nrow(mapper[["variablemap"]]) ) {
     # i <- 2 
     thisvar <-  mapper[["variablemap"]][["variable"]][[i]]
     thismappattern <-  mapper[["variablemap"]][["mappattern"]][[i]]
     
     ## get the list member and variable name based on pattern matching
     thismatch <- varname |>
                 dplyr::mutate( match = grepl(pattern = thismappattern ,
                                              x = value)) |>
                 dplyr::filter( match == TRUE ) 
     
     ## In case multiple pattern match take the first one
     if ( nrow(thismatch) > 1) {
       cli::cli_alert_info(paste0( thisvar ,
   " variable has more than one variable pattern match in the dataset. We will take the first one but good to check... \n")) 
       thismatch <- thismatch |> dplyr::filter( dplyr::row_number() == 1)
       }
     
     ## If matches push!
    if ( nrow(thismatch) ==0) { 
      cli::cli_alert_info(paste0( thisvar ,
           " variable pattern was not found in the dataset.\n"))
      }  else {
     ## Now  transform
     datalist[[mapper[["hierarchy"]] ]] [[ thisvar ]]  <- 
        datalist[[thismatch |> dplyr::pull(df) ]][[thismatch |> dplyr::pull(value)]]
       
    ## Apply modalities transformation
    mod <- mapper[["modalitymap"]] |>
         dplyr::filter( variable == thisvar ) 
    
    datalist[[mapper[["hierarchy"]] ]] [[ thisvar ]] <- plyr::mapvalues(
      x = datalist[[mapper[["hierarchy"]] ]] [[ thisvar ]] ,
      from = mod[["map"]],
      to=  mod[["standard"]])
    
    newlev <- paste(
      levels(as.factor(datalist[[mapper[["hierarchy"]] ]] [[ thisvar ]] )),  
      collapse = ', ')  
    
    ## Inform user
    cat(paste0("Mapped levels for ", 
               thisvar, " are now: ", 
               newlev,
               "\n"))
    rm(thisvar, newlev)
     }
   }
  
   return(datalist)
    
}
```
  
```{r example-fct_re_map}
mapper = list(
            hierarchy = "main",
            variablemap = data.frame(
              label = c("Does this household use anything for lighting?",
                        "What source of electricity is used most of the time in this household?"),
              variable = c("LIGHT01", 
                           "LIGHT03"),
              mappattern = c("LIGHT01", 
                           "LIGHT03") ),
            modalitymap = data.frame(
              variable = c( "LIGHT01", 
                            "LIGHT03", "LIGHT03", "LIGHT03"),
              label = c( "yes",
                "No electricity in household", "Other, specify", "Don't know"),
              standard = c( "1",
                           "1", "96", "98"),
              map = c("yes",
                      "Noelec", "Other", "Dontknow")
            )
          )


## One variable is not correctly 
datalist <- list(mainhousehold = data.frame(
                group.LIGHT01 = c("yes",  "yes",  "no", "yes",  "yes",
                                  "no", "yes",  "yes",  "yes"),
                group.LIGHT03 = c("Noelec", "Other", "Dontknow", "Noelec", "Other",
                                  "Dontknow", "Nuclear", "Other", "Dontknow"))
             )
datalist <- fct_re_map(datalist = datalist, mapper = mapper )

fct_check_map(datalist = datalist, mapper = mapper )
 

```
  
```{r tests-fct_re_map}
test_that("fct_re_map works", {
  expect_true(inherits(fct_re_map, "function")) 
})
```
  

 
 
# Impact Indicators
 
## electricity
    
```{r function-electricity}
#' electricity
#' 
#'  Households lighting provides a sense of safety and security within and outside 
#'  the households after sunset.
#'  
#'  If households lack access to electricity, especially for lighting and 
#'  connectivity, this affects the occupants' security and limits their 
#'  opportunities for socialization, learning and self-reliance.
#'  
#'  **Numerator**: Population with access to electricity, especially for lighting 
#'  and connectivity
#'  
#'  **Denominator**: Total population
#'  
#'  **Formula**: *LIGHT01* = 1 & *LIGHT03* != 1, 96, 98
#' 
#' 
#' @param datalist A list with all hierarchical data frame for a survey data set.
#'    format is expected to match the Excel export synchronized from kobo to RILD
#'    and loaded with  kobocruncher::kobo_data() 
#'                    
#' @param mapper a list providing the mapping of the variables used for the 
#' calculation - this mapper is potentially to be adjusted in relation with deviation
#' between the the standard XlsForm and the contextualized dataset
#'                       
#' 
#' @importFrom dplyr mutate case_when
#' @importFrom labelled labelled
#' 
#' @return new calculated variable - appended or not...
#' 
#' @export
electricity <- function(datalist, 
         mapper = list(
            hierarchy = "main",
            variablemap = data.frame(
              label = c("Does this household use anything for lighting?",
       "What source of electricity is used most of the time in this household?"),
              variable = c("LIGHT01", 
                           "LIGHT03"),
              mappattern = c("LIGHT01", 
                           "LIGHT03") ),
            modalitymap = data.frame(
              variable = c( "LIGHT01", 
                            "LIGHT03", "LIGHT03", "LIGHT03"),
              label = c( "yes",
                        "No electricity in household", "Other, specify", "Don't know"),
              standard = c( "1",
                           "1", "96", "98"),
              map = c("1",
                      "1", "96", "98")))  ) {
  
  ## So first we check that we have what we need in the data set based on the mapper
   fct_check_map(datalist = datalist,
                             mapper = mapper)
  #if (check_map == FALSE) {
  datalist <- fct_re_map(datalist = datalist,
                              mapper = mapper)
 # }
  
  ## now pull the calculation...
  datalist[["main"]]$electricity <-  dplyr::case_when(datalist[["main"]]$LIGHT01=="1" & 
                       (datalist[["main"]]$LIGHT03!="1" | 
                        datalist[["main"]]$LIGHT03!="96" |
                        datalist[["main"]]$LIGHT03!="98")  ~ "1", 
                     TRUE ~ "0" )
  ## Apply Label
  datalist[["main"]]$electricity <- labelled::labelled(  
                            datalist[["main"]]$electricity,
                                 labels = c(
                                   "Yes" = "1",
                                   "No" = "0"
                                 ),
                                 label = "Access to electricity")
  return(datalist)
}
```
  
```{r example-electricity}
datalist <- kobocruncher::kobo_data( here::here("data-raw", "data2.xlsx"))

datalist2 <- electricity( datalist =datalist, 
         mapper = list(
            hierarchy = "main",
            variablemap = data.frame(
              label = c("Does this household use anything for lighting?",
       "What source of electricity is used most of the time in this household?"),
              variable = c("LIGHT01", 
                           "LIGHT03"),
              mappattern = c("LIGHT01", 
                           "LIGHT03") ),
            modalitymap = data.frame(
              variable = c( "LIGHT01", 
                            "LIGHT03", "LIGHT03", "LIGHT03"),
              label = c( "yes",
                        "No electricity in household", "Other, specify", "Don't know"),
              standard = c( "1",
                           "1", "96", "98"),
              map = c("yes",
                      "1", "96", "98")))  )
```
  
```{r tests-electricity}
test_that("electricity works", {
  expect_true(inherits(electricity, "function")) 
})
```
  


 

```{r development-inflate, eval=FALSE}
# Keep eval=FALSE to avoid infinite loop in case you hit the knit button
# Execute in the console directly
fusen::inflate(flat_file = "dev/indicators.Rmd", vignette_name = "Indicators calculation functions")
```

 
