---
title: "Indicators calculation functions"
output: html_document
editor_options: 
  chunk_output_type: console
---

<!-- Run this 'development' chunk -->
<!-- Store every call to library() that you need to explore your functions -->

```{r development, include=FALSE}
library(testthat)
```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

# Data Wrangling

Each indicator calculation is based on predefined frame, variable name and variable value.

Therefore each indicator function is organised in 3  steps:

 * Check if the standard frame/variable/modalities are already present in the dataset (organised as a list..) `fct_check_map`
 
 * If not apply the mapping supplied as argument within the function `fct_re_map`
 
 * Apply the calculation - either to append the new variable to the existing data or to output just the final vector with results. 
 
## fct_check_map

```{r function-fct_check_map}
#' fct_check_map
#' 
#' This check is the standard variable and modalities
#' 
#' @param datalist A list with all hierarchical data frame for a survey data set.
#'    format is expected to match the Excel export synchronized from kobo to RILD
#'    and loaded with  kobocruncher::kobo_data() 
#'                    
#' @param mapper a list providing the mapping of the variables used for the 
#' calculation - this mapper is potentially to be adjusted in relation with deviation
#' between the the standard XlsForm and the contextualized dataset
#' 
#' 
#' @return TRUE or FALSE
#' 
#' @export
fct_check_map <- function(datalist, mapper){

   ## Loop around the variables within mapper
   for ( i in 1:nrow(mapper[["variablemap"]]) ) {
     # i <- 1
     thisvar <-  mapper[["variablemap"]][["variable"]][[i]]
    if ( is.null(datalist[[mapper[["hierarchy"]] ]] [[ thisvar ]]) ) 
    {cli::cli_alert_info(paste0( thisvar ," standard variable was not found in the dataset.\n"))
      }
     else {
       ## If present check modalities
       mod <- mapper[["modalitymap"]] |>
         dplyr::filter( variable == thisvar ) |>
         dplyr::pull(standard)
      
      if( any(levels(as.factor(datalist[[mapper[["hierarchy"]] ]] [[ thisvar ]])) %in%  mod ) )
           { cat(paste0( thisvar ," is in the dataset and has at least one of the expected modality for calculation\n")) } else {
            cli::cli_alert_info(paste0( thisvar ,
                  " standard variable in the dataset misses at least one response among : ",
                                    mod))  }
     }
   }
}
```
  
```{r example-fct_check_map}

mapper = list(
            hierarchy = "main",
            variablemap = data.frame(
              label = c("Does this household use anything for lighting?",
                        "What source of electricity is used most of the time in this household?"),
              variable = c("LIGHT01", 
                           "LIGHT03"),
              mappattern = c("LIGHT01", 
                           "LIGHT03") ),
            modalitymap = data.frame(
              variable = c( "LIGHT01", 
                            "LIGHT03", "LIGHT03", "LIGHT03"),
              label = c( "yes",
                        "No electricity in household", "Other, specify", "Don't know"),
              standard = c( "1",
                           "1", "96", "98"),
              map = c("1",
                      "1", "96", "98")
            )
          )

## Correct format
data <- list(main = data.frame(
                LIGHT01 = c("1",  "1",  "0", "1",  "1",  "0", "1",  "1",  "1"),
                LIGHT03 = c("1", "96", "98", "1", "96", "98", "0", "96", "98"))
             )
fct_check_map(datalist = data, mapper = mapper )

## One variable is not correctly 
data <- list(main = data.frame(
                LIGHT01 = c("1",  "1",  "0", "1",  "1",  "0", "1",  "1",  "1"),
                LIGH03 = c("1", "96", "98", "1", "96", "98", "0", "96", "98"))
             )
fct_check_map(datalist = data, mapper = mapper )

## The first variable does not include a single 1...
data <- list(main = data.frame(
                LIGHT01 = c("0",  "0",  "0", "0",  "0",  "0", "0",  "0",  "0"),
                LIGHT03 = c("1", "96", "98", "1", "96", "98", "0", "96", "98"))
             )
fct_check_map(datalist = data, mapper = mapper )
```
  
```{r tests-fct_check_map}
test_that("fct_check_map works", {
  expect_true(inherits(fct_check_map, "function")) 
})
```

## fct_get_all_variable_names
    
```{r function-fct_get_all_variable_names}
#' fct_get_all_variable_names
#' 
#' Generate a map of all variables within the datalist obtained from RIDL - 
#'   standard Kobo extract in Excel
#' 
#' @param datalist A list with all hierarchical data frame for a survey data set.
#'    format is expected to match the Excel export synchronized from kobo to RILD
#'    and loaded with  kobocruncher::kobo_data() 
#' 
#' @return dataframe with variables and list member names 
#' 
#' @importFrom purrr imap list_rbind
#' @importFrom tibble tibble as_tibble_col
#' @importFrom tidyr unnest
#' 
#' @export
fct_get_all_variable_names <- function(datalist){
  
    dico <- purrr::imap(datalist,
       function(x, y) tibble::tibble(df = y,
                      vars = tibble::as_tibble_col(names(x))) |> 
         tidyr::unnest(vars)) |>
       purrr::list_rbind()
    
    return(dico)
    
}
```
  
```{r example-fct_get_all_variable_names}
data <- kobocruncher::kobo_data( system.file("test.xlsx",
                                             package = "IndicatorCalc"))
varname <-   fct_get_all_variable_names(datalist = data)
head(varname, 10)
```
  
```{r tests-fct_get_all_variable_names}
test_that("fct_get_all_variable_names works", {
  expect_true(inherits(fct_get_all_variable_names, "function")) 
})
```

## fct_re_map
    
```{r function-fct_re_map}
#' fct_re_map
#' 
#' Take a list with a hierarchical survey as an entry - use another list to remap
#' variables and modalities for specific questions 
#' @param datalist A list with all hierarchical data frame for a survey data set.
#'    format is expected to match the Excel export synchronized from kobo to RILD
#'    and loaded with  kobocruncher::kobo_data() 
#'                    
#' @param mapper a list providing the mapping of the variables used for the 
#' calculation - this mapper is potentially to be adjusted in relation with deviation
#' between the the standard XlsForm and the contextualized dataset
#' 
#' @importFrom dplyr filter row_number mutate pull
#' @importFrom cli cli_alert_info
#' @return datalist
#' 
#' @export
fct_re_map <- function(datalist, mapper){
  
   varname <-   fct_get_all_variable_names(datalist)
   ## Loop around the variables within mapper
   for ( i in 1:nrow(mapper[["variablemap"]]) ) {
     # i <- 4 
     thisvar <-  mapper[["variablemap"]][["variable"]][[i]]
     thismappattern <-  mapper[["variablemap"]][["mappattern"]][[i]]
     
     ## get the list member and variable name based on pattern matching
     thismatch <- varname |>
                 dplyr::mutate( match = grepl(pattern = thismappattern ,
                                              x = value)) |>
                 dplyr::filter( match == TRUE ) 
     
     ## In case multiple pattern match take the first one
     if ( nrow(thismatch) > 1) {
       cli::cli_alert_info(paste0( thisvar ,
   " variable has more than one variable pattern match in the dataset. We will take the first one but good to check... \n")) 
       thismatch <- thismatch |> dplyr::filter( dplyr::row_number() == 1)
       }
     
     ## If matches push!
    if ( nrow(thismatch) == 0 ) { 
      cli::cli_alert_info(paste0( thisvar ,
           " variable pattern was not found in the dataset.\n"))
      }  else {
     ## Now  transform
     datalist[[mapper[["hierarchy"]] ]] [[ thisvar ]]  <- 
        datalist[[thismatch |> dplyr::pull(df) ]][[thismatch |> dplyr::pull(value)]]
       
    ## Apply modalities transformation
    mod <- mapper[["modalitymap"]] |>
         dplyr::filter( variable == thisvar ) 
    
    datalist[[mapper[["hierarchy"]] ]] [[ thisvar ]] <- plyr::mapvalues(
      x = datalist[[mapper[["hierarchy"]] ]] [[ thisvar ]] ,
      from = mod[["map"]],
      to=  mod[["standard"]])
    
    newlev <- paste(
      levels(as.factor(datalist[[mapper[["hierarchy"]] ]] [[ thisvar ]] )),  
      collapse = ', ')  
    
    ## Inform user
    cat(paste0("Mapped levels for ", 
               thisvar, " are now: ", 
               newlev,
               "\n"))
    rm(thisvar, newlev)
     }
   }
  
   return(datalist)
    
}
```
  
```{r example-fct_re_map}
mapper = list(
            hierarchy = "main",
            variablemap = data.frame(
              label = c("Does this household use anything for lighting?",
                        "What source of electricity is used most of the time in this household?"),
              variable = c("LIGHT01", 
                           "LIGHT03"),
              mappattern = c("LIGHT01", 
                           "LIGHT03") ),
            modalitymap = data.frame(
              variable = c( "LIGHT01", 
                            "LIGHT03", "LIGHT03", "LIGHT03"),
              label = c( "yes",
                "No electricity in household", "Other, specify", "Don't know"),
              standard = c( "1",
                           "1", "96", "98"),
              map = c("yes",
                      "Noelec", "Other", "Dontknow")
            )
          )


## One variable is not correctly 
datalist <- list(mainhousehold = data.frame(
                group.LIGHT01 = c("yes",  "yes",  "no", "yes",  "yes",
                                  "no", "yes",  "yes",  "yes"),
                group.LIGHT03 = c("Noelec", "Other", "Dontknow", "Noelec", "Other",
                                  "Dontknow", "Nuclear", "Other", "Dontknow"))
             )
datalist <- fct_re_map(datalist = datalist, mapper = mapper )

fct_check_map(datalist = datalist, mapper = mapper )
 

```
  
```{r tests-fct_re_map}
test_that("fct_re_map works", {
  expect_true(inherits(fct_re_map, "function")) 
})
```


## fct_plot_indic_donut
    
```{r function-fct_plot_indic_donut}
#' fct_plot_indic_donut
#' 
#' Wrapper for a summary chart for indicator - allows to add hint, source,  icon
#'  and interpretation threshold if available
#'  
#'  @params indicator vector
#'  @params  subtitle_chart  
#'  @params   caption_chart  
#'  @params    ordered_threhold  vector with the different threshold 
#'    (green, orange, red)
#'  @params   iconunicode  unicode value for fontawesome --- 
#'              see https://fontawesome.com/search?o=r&m=free
#' 
#' 
#' @return ggplot2 object 
#' 
#' @importFrom ggplot2 ggplot labs aes expansion
#' @importFrom  unhcrthemes scale_fill_unhcr_d theme_unhcr
#' @importFrom ggforce geom_arc_bar
#' @importFrom ggtext geom_richtext
#' 
#' @export
fct_plot_indic_donut <- function(indicator,
                                 subtitle_chart = NULL,
                                 caption_chart = NULL,
                                 ordered_threhold = NULL,
                                 iconunicode = "f496"){
  
  
#   # Loading required packages
# library(unhcrthemes)
# library(tidyverse)
# library(ggtext)
# library(ggforce)

# Loading data
#indicator <- datalist[["main"]]$shelter
df2 <-sjmisc::frq(indicator)[[1]]
#df2$label <- factor(df2$label, levels = c( "Yes","No"))

# Plot
plot <- ggplot2::ggplot(df2) +
  ggforce::geom_arc_bar(
    ggplot2::aes( 
        x0 = 0, y0 = 0,
        r0 = 0.6, r = 1,
        amount = raw.prc,
        fill = label  ),
  stat = "pie",  size = 1,  color = "#FFFFFF"  ) +
  
  ggtext::geom_richtext(
    x = 0,  y = 0,
    label = paste0(
      "<span style='font-family: \"Font Awesome 6 Free Solid\" font-size:44pt'>&#x",
      iconunicode,";</span><br><span style='font-size:14pt'>",
      sjlabelled::get_label(indicator),
      "</span><br><strong> ",
      round(df2 |>
              dplyr::filter(val == 1) |>
              dplyr::pull(raw.prc), 2),
      "%</strong>"),
    size = 16 ,  
    fill = NA,  label.color = NA  ) +
  
  ggplot2::labs( #title = sjlabelled::get_label(x ), 
       subtitle = subtitle_chart, 
        caption = caption_chart ) +
  
  ggplot2::scale_x_continuous(expand = ggplot2::expansion(c(0.3, 0.5))) +
  unhcrthemes::scale_fill_unhcr_d( palette = "pal_unhcr", direction = -1) +
  
  unhcrthemes::theme_unhcr( grid = FALSE,  axis = FALSE,
    axis_title = FALSE, axis_text = FALSE, legend = FALSE
  )

#plot

return(plot)
    
}
```
  
```{r example-fct_plot_indic_donut}
test <- data.frame(
  shelter = rbinom(20, 1, 0.5)) |> 
  dplyr::mutate( shelter = 
  labelled::labelled( shelter,
                      labels = c( "Yes" = 1, "No" = 0),
                      label = "Access to adequate shelter")) 
  
fct_plot_indic_donut(indicator = test$shelter,
                     subtitle_chart = NULL,
                     caption_chart = NULL,
                     ordered_threhold = NULL,
                     iconunicode = "e54f") 
```
  
```{r tests-fct_plot_indic_donut}
test_that("fct_plot_indic_donut works", {
  expect_true(inherits(fct_plot_indic_donut, "function")) 
})
```
  


# Impact Indicators
 
## inter_electricity
    
```{r function-inter_electricity}
#' inter_electricity
#' 
#'  Households lighting provides a sense of safety and security within and outside 
#'  the households after sunset.
#'  
#'  If households lack access to electricity, especially for lighting and 
#'  connectivity, this affects the occupants' security and limits their 
#'  opportunities for socialization, learning and self-reliance.
#'  
#'  **Numerator**: Population with access to electricity, especially for lighting 
#'  and connectivity
#'  
#'  **Denominator**: Total population
#'  
#'  **Formula**: *LIGHT01* = 1 & *LIGHT03* != 1, 96, 98
#' 
#' 
#' @param datalist A list with all hierarchical data frame for a survey data set.
#'    format is expected to match the Excel export synchronized from kobo to RILD
#'    and loaded with  kobocruncher::kobo_data() 
#'                    
#' @param mapper a list providing the mapping of the variables used for the 
#' calculation - this mapper is potentially to be adjusted in relation with deviation
#' between the the standard XlsForm and the contextualized dataset
#'                       
#' 
#' @importFrom dplyr mutate case_when
#' @importFrom labelled labelled
#' 
#' @return new calculated variable - appended or not...
#' 
#' @export
inter_electricity <- function(datalist, 
         mapper = list(
            hierarchy = "main",
            variablemap = data.frame(
              label = c("Does this household use anything for lighting?",
       "What source of electricity is used most of the time in this household?"),
              variable = c("LIGHT01", 
                           "LIGHT03"),
              mappattern = c("LIGHT01", 
                           "LIGHT03") ),
            modalitymap = data.frame(
              variable = c( "LIGHT01", 
                            "LIGHT03", "LIGHT03", "LIGHT03"),
              label = c( "yes",
                        "No electricity in household", "Other, specify", "Don't know"),
              standard = c( "1",
                           "1", "96", "98"),
              map = c("1",
                      "1", "96", "98")))  ) {
  
  ## So first we check that we have what we need in the data set based on the mapper
   fct_check_map(datalist = datalist,
                             mapper = mapper)
  #if (check_map == FALSE) {
  datalist <- fct_re_map(datalist = datalist,
                              mapper = mapper)
 # }
  
  ## now pull the calculation...
  datalist[["main"]]$electricity <-  dplyr::case_when(datalist[["main"]]$LIGHT01=="1" & 
                       (datalist[["main"]]$LIGHT03!="1" | 
                        datalist[["main"]]$LIGHT03!="96" |
                        datalist[["main"]]$LIGHT03!="98")  ~ "1", 
                     TRUE ~ "0" )
  ## Apply Label
  datalist[["main"]]$electricity <- labelled::labelled(  
                            datalist[["main"]]$electricity,
                                 labels = c(
                                   "Yes" = "1",
                                   "No" = "0"
                                 ),
                                 label = "Access to electricity")
  return(datalist)
}
```
  
```{r example-inter_electricity}
datalist <- kobocruncher::kobo_data( system.file("test.xlsx", 
                                                 package = "IndicatorCalc"))
mapper <- list(
            hierarchy = "main",
            variablemap = data.frame(
              label = c("Does this household use anything for lighting?",
       "What source of electricity is used most of the time in this household?"),
              variable = c("LIGHT01", 
                           "LIGHT03"),
              mappattern = c("LIGHT01", 
                           "LIGHT03") ),
            modalitymap = data.frame(
              variable = c( "LIGHT01", 
                            "LIGHT03", "LIGHT03", "LIGHT03"),
              label = c( "yes",
                        "No electricity in household", "Other, specify", "Don't know"),
              standard = c( "1",
                           "1", "96", "98"),
              map = c("yes",
                      "1", "96", "98"))) 

datalist <- inter_electricity( datalist =datalist, mapper = mapper  )


table(datalist[["main"]]$electricity)
fct_plot_indic_donut(indicator = datalist[["main"]]$electricity,
                     iconunicode = "f0e7") 

```
  
```{r tests-inter_electricity}
test_that("inter_electricity works", {
  expect_true(inherits(inter_electricity, "function")) 
})
```
  
## inter_healthcare
    
```{r function-inter_healthcare}
#' inter_healthcare
#' 
#' Access to healthcare depends on availability of healthcare, including physical 
#' reach, acceptability and affordability for all.
#' For this indicator, the focus is on the availability of healthcare system.
#' According to [The Sphere Handbook](https://spherestandards.org/wp-content/uploads/Sphere-Handbook-2018-EN.pdf),
#'  primary healthcare facility should be accessible within one hour's walk from dwellings.
#'  **Numerator**: Population that can reach a primary healthcare facility within one hour from dwellings
#'  **Denominator**: Total population
#'  **Formula**: *HEA01* != 96, 98 & *HEA03* <= 60 
#'  (reachable within one hour/60 minutes)
#' 
#'  
#' @param datalist A list with all hierarchical data frame for a survey data set.
#'    format is expected to match the Excel export synchronized from kobo to RILD
#'    and loaded with  kobocruncher::kobo_data() 
#'                    
#' @param mapper a list providing the mapping of the variables used for the 
#' calculation - this mapper is potentially to be adjusted in relation with deviation
#' between the the standard XlsForm and the contextualized dataset
#' 
#' @importFrom dplyr mutate case_when
#' @importFrom labelled labelled
#' @importFrom cli cli_alert_info
#' 
#' @return new calculated variable - appended or not...
#' 
#' @export
#' 
inter_healthcare <- function(datalist, 
         mapper = list(
            hierarchy = "main",
            variablemap = data.frame(
              label = c(
  "In general, when anyone in your household is sick,  where do they go to seek care?",
  "How long does it take to go there when you use the mode of transport that you mentioned above?"),
              variable = c("HEA01", 
                           "HEA03"),
              mappattern = c("HEA01", 
                           "HEA03") ),
            modalitymap = data.frame(
              variable = c( "HEA01", "HEA01" ),
              label = c(  "Other, specify", "Don't know"),
              standard = c("96", "98" ),
              map = c("96", "98" ))) ){
  
  ## So first we check that we have what we need in the data set based on the mapper
  check_map <- fct_check_map(datalist = datalist,
                             mapper = mapper)
  #if (check_map == FALSE) {
    datalist <- fct_re_map(datalist = datalist,
                              mapper = mapper)
  #}
  

datalist[["main"]]$healthcare <- 
           dplyr::case_when((datalist[["main"]]$HEA01!="96" | 
                               datalist[["main"]]$HEA01!="98") & 
                              datalist[["main"]]$HEA03 <= 60 ~ "1",
                     TRUE ~ "0")

datalist[["main"]]$healthcare = labelled::labelled(datalist[["main"]]$healthcare,
                                labels = c(
                                  "Yes" = "1",
                                  "No" = "0"),
                                label = "Access to healthcare facility")

return(datalist)
}
```
  
```{r example-inter_healthcare}
datalist <- kobocruncher::kobo_data( system.file("test.xlsx",
                                                 package = "IndicatorCalc"))

mapper <-  list(
            hierarchy = "main",
            variablemap = data.frame(
              label = c(
"In general, when anyone in your household is sick, where do they go to seek care?",
"How long it takes to go there when you use the mode of transport mentioned above?"),
              variable = c("HEA01", 
                           "HEA03"),
              mappattern = c("HEA01", 
                           "HEA03") ),
            modalitymap = data.frame(
              variable = c( "HEA01", "HEA01" ),
              label = c(  "Other, specify", "Don't know"),
              standard = c("96", "98" ),
              map = c("96", "98" )))

datalist <- inter_healthcare(datalist, mapper )

table(datalist[["main"]]$healthcare)
fct_plot_indic_donut(indicator = datalist[["main"]]$healthcare,
                     iconunicode = "f479") 

```
  
```{r tests-inter_healthcare}
test_that("healthcare works", {
  expect_true(inherits(inter_healthcare, "function")) 
})
```

## inter_drinkingwater
    
```{r function-inter_drinkingwater}
#' inter_drinkingwater
#' 
#' Access to clean drinking water is essential for a person's survival and well 
#' being and a precursor for achieving protection outcomes related to health, 
#' education and economic developed.
#' The calculation for access drinking water is linked to SGD Indicator
#'  [6.1.1](https://unstats.un.org/sdgs/metadata/files/Metadata-06-01-01.pdf).
#'  The questionnaire module and the analysis guidance is taken from [UNICEF MICS6](https://mics.unicef.org/tools#analysis).
#'  
#'  **Numerator**: Population using improved sources of drinking water either in their dwelling/yard/plot or within 30 minutes round trip collection time
#'  
#'  **Denominator**: Total population
#'  
#'  **Formula**: 
#'   *DWA03* < 30 (under 30 minutes), &
#'   *DWA01* != 7,9,13,96,98 &
#'   *DWA02* != 3
#'   
#'  This basic service is calculated from the main dataset
#'  There are three conditions as below  improved source, 
#'  in dwelling/yard/plot and reachable under 30 minutes 
#' 
#' @param datalist A list with all hierarchical data frame for a survey data set.
#'    format is expected to match the Excel export synchronized from kobo to RILD
#'    and loaded with  kobocruncher::kobo_data() 
#'                    
#' @param mapper a list providing the mapping of the variables used for the 
#' calculation - this mapper is potentially to be adjusted in relation with deviation
#' between the the standard XlsForm and the contextualized dataset
#' 
#' 
#' @importFrom dplyr mutate case_when
#' @importFrom labelled labelled
#' 
#' @return new calculated variable - appended or not...
#' 
#' @export
inter_drinkingwater <- function(
        datalist, 
         mapper = list(
            hierarchy = "main",
            variablemap = data.frame(
              label = c(
                "What is the main source of drinking water for this household?",
                "Where is this source located?",
                "Unit used to measure time to access",
                "How long does it take to go there, get water, and come back,
                  including waiting time?"),
              variable = c("DWA01", 
                           "DWA02", 
                           "DWA03a", 
                           "DWA03b" ),
              mappattern = c("DWA01", 
                           "DWA02", 
                           "DWA03a", 
                           "DWA03b" ) ),
             modalitymap = data.frame(
             variable = c("DWA01", 
                          "DWA01", 
                          "DWA01", 
                          "DWA01", 
                          "DWA01", 
                           "DWA02",
                           "DWA02",
                           "DWA02",
                           "DWA03a",
                           "DWA03a"),
              label = c( 
                ##DWA01
                "Unprotected Dug Well", 
                "Unprotected Spring",
                "Surface Water (River, Stream, Pond, Dam, Canal)",
                "Other, specify",
                "Don't know",
                ##DWA02
                "In Own Dwelling", 
                "In Own Yard/Plot",
                "Elsewhere",
                ## DWA03
                "Minutes", "Hours" ),
              standard = c( "7", "9", "13", "96", "98",
                           "1", "2", "3",
                           "1", "2"),
              map = c( "7", "9", "13", "96", "98",
                       "1", "2", "3",
                        "1", "2"))) 
         ){
  
    ## So first we check that we have what we need in the data set based on the mapper
  check_map <- fct_check_map(datalist = datalist,
                             mapper = mapper)
 # if (check_map == FALSE) {
    datalist <- fct_re_map(datalist = datalist,
                              mapper = mapper)
 # }
  
datalist[["main"]]$time_DWA <-  dplyr::case_when(
    datalist[["main"]]$DWA03a=="1"~ 1, 
    datalist[["main"]]$DWA03a=="2"~ 60) #convert hour into minutes
# datalist[["main"]]$time_DWA <- as.numeric(datalist[["main"]]$time_DWA)

datalist[["main"]]$time_tot <- datalist[["main"]]$time_DWA * 
    as.numeric(datalist[["main"]]$DWA03b)

datalist[["main"]]$reachableU30 <-  dplyr::case_when( 
  datalist[["main"]]$time_tot > 30 ~ "0", 
                              TRUE ~ "1") # reachable under 30 minutes

datalist[["main"]]$dwa_cond1 <-  dplyr::case_when(
  datalist[["main"]]$DWA01!="7" |
  datalist[["main"]]$DWA01 !="9" |
  datalist[["main"]]$DWA01 != "13" | 
  datalist[["main"]]$DWA01 != "96" |
  datalist[["main"]]$DWA01 !="98" ~ "1",
                             TRUE ~ "0") # improved source

datalist[["main"]]$dwa_cond2= dplyr::case_when( 
  
  #UNDER30 MIN
  datalist[["main"]]$reachableU30 == "1" & 
  datalist[["main"]]$DWA02 == "3" ~ "1", 
  
  # NOT UNDER30 MIN
  datalist[["main"]]$reachableU30 == "0" & 
  datalist[["main"]]$DWA02 == "3" ~ "0", 
  
  # in the dwelling/yard/plot
  datalist[["main"]]$DWA02 == "1" | 
  datalist[["main"]]$DWA02 == "2" ~ "1", 
    TRUE ~ NA_character_ ) 

datalist[["main"]]$drinkingwater <- dplyr::case_when(
    (datalist[["main"]]$dwa_cond1 == "1" & 
      datalist[["main"]]$dwa_cond2 == "1" ) ~ "1", 
    TRUE ~ "0")

datalist[["main"]]$drinkingwater = labelled::labelled(datalist[["main"]]$drinkingwater,
                                  labels = c(
                                    "Yes" = "1",
                                    "No" = "0"
                                  ),
                                  label = "Access to drinking water")
    return(datalist)
}
```
  
```{r example-inter_drinkingwater}
datalist <- kobocruncher::kobo_data( system.file("test.xlsx",
                                                 package = "IndicatorCalc"))

## in the contextualised form - DWA03a has been skipped and all results are in min... 
## only manual transformation can adjust this before we use the mapper..

datalist[["main"]]$DWA03a  <- "1" 

datalist[["main"]]$DWA03b <- 
  datalist[["main"]]$VulnerabilityScoring.BasicNeeds.DWA03

# now the mapper
mapper <-  list(
            hierarchy = "main",
            variablemap = data.frame(
              label = c(
   "What is the main source of drinking water for this household?",
  "Where is this source located?",
  "Unit used to measure time to access",
  "How long does it take to go there, wait get water, and come back?"),
              variable = c("DWA01", 
                           "DWA02", 
                           "DWA03a", 
                           "DWA03b" ),
              mappattern = c("DWA01", 
                           "DWA02", 
                           "DWA03a", 
                           "DWA03b" ) ),
            modalitymap = data.frame(
             variable = c("DWA01",  "DWA01", "DWA01","DWA01",  "DWA01", 
                   "DWA02","DWA02", "DWA02",
                   "DWA03a","DWA03a"),
             label = c( 
                ##DWA01
                "Unprotected Dug Well", 
                "Unprotected Spring",
                "Surface Water (River, Stream, Pond, Dam, Canal)",
                "Other, specify",
                "Don't know",
                ##DWA02
                "In Own Dwelling", 
                "In Own Yard/Plot",
                "Elsewhere",
                ## DWA03a
                "Minutes", 
                "Hours"    ),
             standard = c( "7", "9", "13", "96", "98",
                           "1", "2", "3",
                           "1", "2"),
             map = c( "7", "9", "13", "96", "98",
                       "1", "2", "3",
                        "1", "2") ) 
         )
  
datalist <- inter_drinkingwater(datalist, mapper )

## Indicator summary
table(datalist[["main"]]$drinkingwater, useNA = "ifany")
fct_plot_indic_donut(indicator = datalist[["main"]]$drinkingwater,
                     iconunicode = "e006") 

## Check auxilliary
table(datalist[["main"]]$dwa_cond1, useNA = "ifany")
table(datalist[["main"]]$reachableU30, useNA = "ifany")
table(datalist[["main"]]$DWA02, useNA = "ifany")
table(datalist[["main"]]$dwa_cond2, useNA = "ifany")
```
  
```{r tests-inter_drinkingwater}
test_that("drinkingwater works", {
  expect_true(inherits(inter_drinkingwater, "function")) 
})
```

## inter_shelter
    
```{r function-inter_shelter}
#' inter_shelter
#' 
#' The right to access adequate housing is protected by international law.
#' The concept of "adequacy" means that housing is more than four walls and a 
#' roof as indicated in [The Sphere Handbook](https://spherestandards.org/wp-content/uploads/Sphere-Handbook-2018-EN.pdf).
#' Habitable housing primarily refers to the fact that the housing should provide
#'  protection from cold, damp, heat, rain, wind, and other threats to health,
#'   structural hazards, and disease vectors and it should not be overcrowded.
#'   As shelter/housing is primarily a contextual element, there may be 
#'   discrepancies from country to country on how this data is measured.
#'   
#'   Adequate shelter is measured based on having improved material for the
#'    dwelling as indicated in [DHS](https://dhsprogram.com/pubs/pdf/AS61/AS61.pdf) 
#'    publication on housing conditions which is also used by [MICS6](https://mics.unicef.org/tools).
#'    
#'    Overcrowding is also used which occurs if there are more than three people
#'     per habitable room as defined by [UN-Habitat](https://www.ncbi.nlm.nih.gov/books/NBK535289/table/ch3.tab2/).
#'     
#'     **Numerator**: Population that have access to adequate housing
#'     **Denominator**: Total population
#'     
#' **Formula**: 
#' 
#'      *DWE01* = 1,2 &
#'      *DWE02* = 3,4,5,6,7,8,9 & 
#'      *DWE03* = 8,9,10,11,12,13 & 
#'      *DWE04* = 10,11,12,13,14,15 & 
#'      crowding (*HH01*/*DWE05*) \<= 3
#' 
#' Adequate shelter is calculated from the main dataset
#' classify as habitable when improved/adequate shelter
#' 
#' @param datalist A list with all hierarchical data frame for a survey data set.
#'    format is expected to match the Excel export synchronized from kobo to RILD
#'    and loaded with  kobocruncher::kobo_data() 
#'                    
#' @param mapper a list providing the mapping of the variables used for the 
#' calculation - this mapper is potentially to be adjusted in relation with deviation
#' between the the standard XlsForm and the contextualized dataset
#' 
#' @importFrom dplyr mutate case_when
#' @importFrom labelled labelled
#' 
#' @return new calculated variable - appended or not...
#' 
#' @export
inter_shelter <- function(datalist, 
         mapper = list(
            hierarchy = "main",
            variablemap = data.frame(
              label = c(
                "What type of dwelling does the household live in?",
"Main material of the dwelling floor",
"Main material of the roof",
"Main material of the exterior walls",
"How many separate rooms do the members of your household occupy?",
"What is the total number of persons in this household?"),
              variable = c("DWE01","DWE02","DWE03","DWE04","DWE05", 
                           "HH01"),
              mappattern = c("DWE01","DWE02","DWE03","DWE04","DWE05", 
                           "HH01") ),
            modalitymap = data.frame(
              variable = c( "DWE01","DWE01",
                            "DWE02","DWE02","DWE02",
                            "DWE03","DWE03","DWE03","DWE03","DWE03","DWE03",
                            "DWE04","DWE04","DWE04","DWE04","DWE04","DWE04"),
              label = c(  "Apartment", "House", # DWE01
                         "Earth/sand", "Dung", "Other (Specify)", #DWE02
                         
                         "Metal/tin", "Wood", "Calamine/Cement fibre", 
                         "Ceramic tiles", "Cement", "Roofing shingles",#DWE03
                         
                         "Cement", "Stone with lime/ cement", "Bricks", 
                         "Cement blocks", "Covered adobe", "Wood planks/shingles" # DWE04
                         ),
              standard = c( "1","2",
                           "1", "2","96",
                           "8","9","10","11","12","13",
                           "10","11","12","13","14","15"),
              map = c("1","2",
                           "1", "2","96",
                           "8","9","10","11","12","13",
                           "10","11","12","13","14","15")))  ){
  
  ## So first we check that we have what we need in the data set based on the mapper
  check_map <- fct_check_map(datalist = datalist,
                             mapper = mapper)
 # if (check_map == FALSE) {
    datalist <- fct_re_map(datalist = datalist,
                              mapper = mapper)
 # }
    
 #Only apartment and house
datalist[["main"]]$dwe01_cat <- 
  dplyr::case_when(
    (datalist[["main"]]$DWE01=="1" | 
     datalist[["main"]]$DWE01=="2") ~ "1", 
    TRUE ~ "0" )
## unimproved floor when earth,sand,clay,mud, dung or other
datalist[["main"]]$dwe02_cat= dplyr::case_when( 
    (datalist[["main"]]$DWE02=="1" | 
     datalist[["main"]]$DWE02=="2" | 
     datalist[["main"]]$DWE02=="96") ~ "0", 
    TRUE ~ "1" )
## unimproved roof all options except metal,wood,ceramic tiles, cement, roofing shingles/sheets
datalist[["main"]]$dwe03_cat= dplyr::case_when( 
    (datalist[["main"]]$DWE03=="8" |
     datalist[["main"]]$DWE03=="9" | 
     datalist[["main"]]$DWE03=="10" | 
     datalist[["main"]]$DWE03=="11" |
     datalist[["main"]]$DWE03=="12" | 
     datalist[["main"]]$DWE03=="13" ) ~ "1" , 
    TRUE ~ "0")

## improved wall: cement,stone,bricks,cement blocks, covered adobe, wood planks
datalist[["main"]]$dwe04_cat= dplyr::case_when( 
    (datalist[["main"]]$DWE04=="10"| 
    datalist[["main"]]$DWE04=="11"| 
    datalist[["main"]]$DWE04=="12"| 
    datalist[["main"]]$DWE04=="13"| 
    datalist[["main"]]$DWE04=="14"| 
    datalist[["main"]]$DWE04=="15") ~ "1",
    TRUE ~ "0")

## Calculate crowding index - overcrowded when more than 3 persons
datalist[["main"]]$crowding <- as.numeric(datalist[["main"]]$HH01) / 
     as.numeric(datalist[["main"]]$DWE05)

datalist[["main"]]$dwe05_cat= dplyr::case_when( ##if crowding <= 3, not overcrowded 
    datalist[["main"]]$crowding <= 3 ~ "1", 
    TRUE ~ "0")
  
####Calculate if all 5 conditions are met for adequate shelter
##dwe01_cat / dwe02_cat / dwe03_cat / dwe04_cat / dwe05_cat

datalist[["main"]]$shelter= dplyr::case_when(
    datalist[["main"]]$dwe01_cat=="0" | 
    datalist[["main"]]$dwe02_cat=="0" | 
    datalist[["main"]]$dwe03_cat=="0" | 
    datalist[["main"]]$dwe04_cat=="0" | 
    datalist[["main"]]$dwe05_cat=="0"  ~ "0", 
    
    datalist[["main"]]$dwe01_cat=="1" & 
    datalist[["main"]]$dwe02_cat=="1" & 
    datalist[["main"]]$dwe03_cat=="1" & 
    datalist[["main"]]$dwe04_cat=="1" & 
    datalist[["main"]]$dwe05_cat=="1" ~ "1")

datalist[["main"]]$shelter = labelled::labelled(
  datalist[["main"]]$shelter,
         labels = c(
                               "Yes" = "1",
                               "No" = "0"
                             ),
                             label = "Access to adequate shelter") 
return(datalist)
}
```
  
```{r example-inter_shelter}
datalist <- kobocruncher::kobo_data( system.file("test.xlsx", 
                                                 package = "IndicatorCalc"))

mapper <- list(
            hierarchy = "main",
            variablemap = data.frame(
              label = c(
                "What type of dwelling does the household live in?",
"Main material of the dwelling floor",
"Main material of the roof",
"Main material of the exterior walls",
"How many separate rooms do the members of your household occupy?",
"What is the total number of persons in this household?"),
              variable = c("DWE01","DWE02","DWE03","DWE04","DWE05", 
                           "HH01"),
              mappattern = c("DWE01","DWE02","DWE03","DWE04","DWE05", 
                           "progres_groupsize") ),
            modalitymap = data.frame(
              variable = c( "DWE01","DWE01",
                            "DWE02","DWE02","DWE02",
                            "DWE03","DWE03","DWE03","DWE03","DWE03","DWE03",
                            "DWE04","DWE04","DWE04","DWE04","DWE04","DWE04"),
              label = c(  "Apartment", "House", # DWE01
                         "Earth/sand", "Dung", "Other (Specify)", #DWE02
                         
                         "Metal/tin", "Wood", "Calamine/Cement fibre", 
                         "Ceramic tiles", "Cement", "Roofing shingles",#DWE03
                         
                         "Cement", "Stone with lime/ cement", "Bricks", 
                         "Cement blocks", "Covered adobe", "Wood planks/shingles" # DWE04
                         ),
              standard = c( "1","2",
                           "1", "2","96",
                           "8","9","10","11","12","13",
                           "10","11","12","13","14","15"),
              map = c("1","2",
                           "1", "2","96",
                           "8","9","10","11","12","13",
                           "10","11","12","13","14","15"))) 
## Calculate
datalist <-  inter_shelter(datalist, mapper)
# Tabulate
table(datalist[["main"]]$dwe01_cat)
table(datalist[["main"]]$dwe02_cat)
table(datalist[["main"]]$dwe03_cat)
table(datalist[["main"]]$dwe04_cat)
table(datalist[["main"]]$dwe05_cat)
table(datalist[["main"]]$shelter)
#plot
fct_plot_indic_donut(datalist[["main"]]$shelter,
                     iconunicode = "e54f") 
```
  
```{r tests-inter_shelter}
test_that("shelter works", {
  expect_true(inherits(inter_shelter, "function")) 
})
```
  

## impact_2_2 
    
```{r function-impact_2_2}
#' impact_2_2
#' 
#' **Proportion of Persons of Concern residing in physically safe and secure 
#' settlements with access to basic facilities**
#' 
#' Once electricity, healthcare, drinking water and adequate shelter are
#'  calculated, check the values for each variable before, 
#'  calculating 2.2 impact indicator. 
#'  
#'  Once all variables are correctly calculated, we can compute the final 
#'  variable for impact 2.2 indicator.
#'  **Numerator**: Population residing in physically safe and secure settlements with access to basic facilities
#'  **Denominator**: Total population
#'  **Formula**: *shelter*=1 & *electricity*=1 & *healthcare*=1 & *drinkingwater*=1
#'  
#'  Impact 2.2 is "1" if all services above are accessible
#' 
#' @param datalist A list with all hierarchical data frame for a survey data set.
#'    format is expected to match the Excel export synchronized from kobo to RILD
#'    and loaded with  kobocruncher::kobo_data() 
#'                    
#' @param mapper a list providing the mapping of the variables used for the 
#' calculation - this mapper is potentially to be adjusted in relation with deviation
#' between the the standard XlsForm and the contextualized dataset
#'                       
#' 
#' @importFrom dplyr mutate case_when
#' @importFrom labelled labelled
#' 
#' @return new calculated variable - appended or not...
#' 
#' @export
impact_2_2 <- function(datalist, 
         mapper = list(
            hierarchy = "main",
            variablemap = data.frame(
              label = c("Access to shelter", 
                        "Access to electricity", 
                         "Access to drinking water", 
                         "Access to  healthcare"),
              variable = c("shelter", 
                           "electricity", 
                           "drinkingwater", 
                           "healthcare"),
              mappattern = c("shelter", 
                           "electricity", 
                           "drinkingwater", 
                           "healthcare") ),
            modalitymap = data.frame(
              variable = c( "shelter", "shelter",
                           "electricity",  "electricity", 
                           "drinkingwater", "drinkingwater", 
                           "healthcare","healthcare"),
              label = c( "Yes","No",
                       "Yes","No",
                       "Yes","No",
                       "Yes","No"),
              standard = c( "1","0",
                           "1","0",
                           "1","0",
                           "1","0"),
              map = c("1","0",
                           "1","0",
                           "1","0",
                           "1","0")))  ){
  
  ## So first we check that we have what we need in the data set based on the mapper
  check_map <- fct_check_map(datalist = datalist,
                             mapper = mapper)

  
datalist[["main"]]$impact2_2 <- dplyr::case_when(
    datalist[["main"]]$shelter=="0" | 
    datalist[["main"]]$electricity=="0" | 
    datalist[["main"]]$drinkingwater=="0" | 
    datalist[["main"]]$healthcare=="0" ~ "0",
    
    datalist[["main"]]$shelter=="1" & 
    datalist[["main"]]$electricity=="1" & 
    datalist[["main"]]$drinkingwater=="1" & 
    datalist[["main"]]$healthcare=="1" ~ "1")

datalist[["main"]]$impact2_2 <- labelled::labelled(
  datalist[["main"]]$impact2_2,
                            labels =c(
                              "Yes"="1",
                              "No"="0"
                            ),
    label="Proportion of PoCs residing in physically safe and secure settlements with access to basic facilities") 

return(datalist)
}
```
  
```{r example-impact_2_2}
datalist <- kobocruncher::kobo_data( system.file("test.xlsx",
                                                 package = "IndicatorCalc"))

#Healthcare
mapper <-  list(
            hierarchy = "main",
            variablemap = data.frame(
              label = c(
  "In general, when anyone in your household is sick, 
   where do they go to seek care?",
  "How long does it take to go there when you use the mode of transport 
  that you mentioned above?"),
              variable = c("HEA01", 
                           "HEA03"),
              mappattern = c("HEA01", 
                           "HEA03") ),
            modalitymap = data.frame(
              variable = c( "HEA01", "HEA01" ),
              label = c(  "Other, specify", "Don't know"),
              standard = c("96", "98" ),
              map = c("96", "98" )))

datalist <- inter_healthcare(datalist, mapper )

## Electricity
mapper <- list(
            hierarchy = "main",
            variablemap = data.frame(
              label = c("Does this household use anything for lighting?",
       "What source of electricity is used most of the time in this household?"),
              variable = c("LIGHT01", 
                           "LIGHT03"),
              mappattern = c("LIGHT01", 
                           "LIGHT03") ),
            modalitymap = data.frame(
              variable = c( "LIGHT01", 
                            "LIGHT03", "LIGHT03", "LIGHT03"),
              label = c( "yes",
                        "No electricity in household", "Other, specify", "Don't know"),
              standard = c( "1",
                           "1", "96", "98"),
              map = c("yes",
                      "1", "96", "98"))) 

datalist <- inter_electricity( datalist =datalist, mapper = mapper  )

## Drinking Water
## in the contextualised form - DWA03a has been skipped and all results are in min... 
## only manual transformation can adjust this before we use the mapper..

datalist[["main"]]$DWA03a  <- "1" 

datalist[["main"]]$DWA03b <- 
  datalist[["main"]]$VulnerabilityScoring.BasicNeeds.DWA03

# now the mapper
mapper <-  list(
            hierarchy = "main",
            variablemap = data.frame(
              label = c(
               "What is the main source of drinking water for this household?",
               "Where is this source located?",
               "Unit used to measure time to access",
               "How long does it take to go there, get water, and come back,
                including waiting time?"),
              variable = c("DWA01", 
                           "DWA02", 
                           "DWA03a", 
                           "DWA03b" ),
              mappattern = c("DWA01", 
                           "DWA02", 
                           "DWA03a", 
                           "DWA03b" ) ),
            modalitymap = data.frame(
             variable = c("DWA01",  "DWA01", "DWA01","DWA01",  "DWA01", 
                   "DWA02","DWA02", "DWA02",
                   "DWA03a","DWA03a"),
             label = c( 
                ##DWA01
                "Unprotected Dug Well", 
                "Unprotected Spring",
                "Surface Water (River, Stream, Pond, Dam, Canal)",
                "Other, specify",
                "Don't know",
                ##DWA02
                "In Own Dwelling", 
                "In Own Yard/Plot",
                "Elsewhere",
                ## DWA03a
                "Minutes", 
                "Hours"    ),
             standard = c( "7", "9", "13", "96", "98",
                           "1", "2", "3",
                           "1", "2"),
             map = c( "7", "9", "13", "96", "98",
                       "1", "2", "3",
                        "1", "2") ) 
         )
  
datalist <- inter_drinkingwater(datalist, mapper )

##Shelter
mapper <- list(
            hierarchy = "main",
            variablemap = data.frame(
              label = c(
                "What type of dwelling does the household live in?",
"Main material of the dwelling floor",
"Main material of the roof",
"Main material of the exterior walls",
"How many separate rooms do the members of your household occupy?",
"What is the total number of persons in this household?"),
              variable = c("DWE01","DWE02","DWE03","DWE04","DWE05", 
                           "HH01"),
              mappattern = c("DWE01","DWE02","DWE03","DWE04","DWE05", 
                           "progres_groupsize") ),
            modalitymap = data.frame(
              variable = c( "DWE01","DWE01",
                            "DWE02","DWE02","DWE02",
                            "DWE03","DWE03","DWE03","DWE03","DWE03","DWE03",
                            "DWE04","DWE04","DWE04","DWE04","DWE04","DWE04"),
              label = c(  "Apartment", "House", # DWE01
                         "Earth/sand", "Dung", "Other (Specify)", #DWE02
                         
                         "Metal/tin", "Wood", "Calamine/Cement fibre", 
                         "Ceramic tiles", "Cement", "Roofing shingles",#DWE03
                         
                         "Cement", "Stone with lime/ cement", "Bricks", 
                         "Cement blocks", "Covered adobe", "Wood planks/shingles" # DWE04
                         ),
              standard = c( "1","2",
                           "1", "2","96",
                           "8","9","10","11","12","13",
                           "10","11","12","13","14","15"),
              map = c("1","2",
                           "1", "2","96",
                           "8","9","10","11","12","13",
                           "10","11","12","13","14","15"))) 
## Calculate
datalist <-  inter_shelter(datalist, mapper)

## and now impact

mapper <-   list(
            hierarchy = "main",
            variablemap = data.frame(
              label = c("Access to shelter", 
                        "Access to electricity", 
                         "Access to drinking water", 
                         "Access to  healthcare"),
              variable = c("shelter", 
                           "electricity", 
                           "drinkingwater", 
                           "healthcare"),
              mappattern = c("shelter", 
                           "electricity", 
                           "drinkingwater", 
                           "healthcare") ),
            modalitymap = data.frame(
              variable = c( "shelter", "shelter",
                           "electricity",  "electricity", 
                           "drinkingwater", "drinkingwater", 
                           "healthcare","healthcare"),
              label = c( "Yes","No",
                       "Yes","No",
                       "Yes","No",
                       "Yes","No"),
              standard = c( "1","0",
                           "1","0",
                           "1","0",
                           "1","0"),
              map = c("1","0",
                           "1","0",
                           "1","0",
                           "1","0")))
 
datalist <-  impact_2_2(datalist, mapper)

fct_plot_indic_donut(indicator = datalist[["main"]]$impact2_2,
                     iconunicode = "f140") 
```
  
```{r tests-impact_2_2}
test_that("impact2_2 works", {
  expect_true(inherits(impact_2_2, "function")) 
})
```
  


 

```{r development-inflate, eval=FALSE}
# Keep eval=FALSE to avoid infinite loop in case you hit the knit button
# Execute in the console directly
fusen::inflate(flat_file = "dev/indicators.Rmd", vignette_name = "Development")
```

 
