---
title: "Supporting functions behind indicators calculation"
output: html_document
editor_options: 
  chunk_output_type: console
---

<!-- Run this 'development' chunk -->
<!-- Store every call to library() that you need to explore your functions -->

```{r development, include=FALSE}
library(testthat)
```

<!--
 You need to run the 'description' chunk in the '0-dev_history.Rmd' file before continuing your code there.

If it is the first time you use {fusen}, after 'description', you can directly run the last chunk of the present file with inflate() inside.
--> 



```{r development-load}
# Run all this chunk in the console directly
# There already is a dataset in the "inst/" directory
# Make the dataset file available to the current Rmd during development
pkgload::load_all(path = here::here(), export_all = FALSE)
```



Indicator functions are designed to work based on data stored as a list - which is the default structure for a complex hierarchical survey dataset with nested tables.
 
The default export format from kobotoolbox includes variables names generated as a concatenation of groups and names.
 
The indicators calculation are based  on specific patterns to be identified within the variable names. This allow to handle cases where variables and questions would have been shifted within the sequence of the questionnaire and through different questions groups.
 
The indicator functions also check that the data content is the one expected. 

A check log is displayed in the console to keep track of all issues
 

# Generating data from a specific form definition

One key function is to generate a dummy dataset based on a specific form structure
To demonstrate the package we will use the standard questionnaire and then apply each indicator function to demonstrate them.
 
We can then also re-use the function to create dummy data based on any form and then apply each indicator function to actually verify which indicators can be created based on the form content.

## fct_var_dummy
    
```{r function-fct_var_dummy}
#' fct_var_dummy 
#' 
#'  Append to an existing dataframe new Generate the variable based on 1. type, 2. constraint and 3.relevance
#'  
#' @param frame dataframe object where new dummy varaible will be created...
#' @param name name of the variable to be created
#' @param type type of the variable to be created in line with xlsform  -
#'             one of the following 6 options:  
#'        "select_one", "select_multiple", "text", "integer", "numeric", "date"
#'        
#'         "start ", "end", "calculate",  "geopoint","acknowledge",
#'         "begin_group", "end_group", "begin_repeat", "end_repeat" , "note"  
#'             
#' @param list_opt  a vector with all possible values for select_one and select_multiple
#'                   - can be null
#' @param constraint  specific constraint - used for for numeric or integer
## @param seed random seed
#' 
#' @return  dataframe
#' 
#' @importFrom withr with_seed
#' @importFrom dplyr mutate n tibble rename
#' @importFrom stats rlnorm
#' @importFrom tidyr unnest
#' 
#' @noRd
#' 
#' @export
fct_var_dummy <- function( frame,
                       name, 
                       type,
                       list_opt, 
                       constraint #,
                     #  seed = 1976
                     )  {
   ## number of records to be generated depends on the initial frame..
   n <- nrow(frame)
   #withr::with_seed(seed = seed)
  # withr::with_seed(
   # seed = seed,
   # suppressWarnings(

       # no content ###########
      if( type %in% c("begin_group", "end_group", "begin_repeat", "end_repeat" , "note" )) {
        res <- dplyr::tibble(
             thisvar = NA)
        names(res)[1] <- name
        frame <- cbind(frame,res)
      }
   
   
       ## acknowledge ###########
      if( type %in% c("acknowledge")) {
        res <- dplyr::tibble(
             thisvar = sample(c(0,1), n, replace = TRUE))
        names(res)[1] <- name
        frame <- cbind(frame,res)
      }
   
   
      ## select one ###########
      if( type %in% c("select_one") ) {
      res <- dplyr::tibble( thisvar = sample(c(list_opt), n, replace = TRUE) ) 
      ## Now rename the variable
      names(res)[1] <- name
      frame <- cbind(frame,res)
      }
      
      ## select multiple ###########
      if( type %in% c("select_multiple")) {
            for (modality in list_opt) {
                res <- dplyr::tibble(
                 thisvar = sample(c(0,1), n, replace = TRUE)) 
                names(res)[1] <- paste0(name, "_",modality )
                frame <- cbind(frame,res)
            }
      }

      ## stext ###########
      if( type %in% c("text")) {
      res <- dplyr::tibble(
        thisvar = paste0( "FreeText_",
                      purrr::as_vector(
                            purrr::map(n, sample(LETTERS, 6)) |>
                            purrr::map(paste0, collapse = "")),
                          "-",
                          formatC(1:n, width = nchar(n) + 1, flag = "0")
                        ))
      ## Now rename the variable
      names(res)[1] <- name
      frame <- cbind(frame,res)
      }
      
     ## numeric ###########    
     if( type %in% c("numeric", "integer", "calculate", "geopoint")) {
      ## TODO extract elements from constraint to define num1 an num2
      num1 <-  0
      num2 <-  95
      
      res <- dplyr::tibble(
        thisvar = sample(num1:num2, n, replace = TRUE))
      ## Now rename the variable
      names(res)[1] <- name
      frame <- cbind(frame,res)
     }

     ## date ###########   
     if( type %in% c("date",  "start", "end")) {
      res <- dplyr::tibble(
        thisvar  = Sys.time() - abs(rnorm(n, 0, sd = 2) * 365 * 24 * 3600))
      ## Now rename the variable
      names(res)[1] <- name
      frame <- cbind(frame,res)
     }

   # )
  # )

  return(frame)  
}
```
  
```{r example-fct_var_dummy}

## let's initiate a dataframe with an index of n r records
n <- 384
frame <- dplyr::tibble(
        index = paste0( "ID-",
                      purrr::as_vector(
                            purrr::map(n, sample(LETTERS, 4)) |>
                            purrr::map(paste0, collapse = "")),
                          "-",
                          formatC(1:n, width = nchar(n) + 1, flag = "0")
                        ))

## test inject select_one  
frame <- fct_var_dummy( 
          frame = frame,
           name = "testselect_one",
           type = "select_one",
           list_opt = c("alpha", "beta", "delta"),
           constraint = NULL
           )
## test inject select_multiple in main
frame <- fct_var_dummy( 
          frame = frame,
          name = "testselect_multiple",
           type = "select_multiple",
           list_opt = c("alpha", "beta", "delta"),
           constraint = NULL
           )

## test inject text
frame <- fct_var_dummy( 
          frame = frame,
          name = "testtext",
           type = "text",
           list_opt = NULL,
           constraint = NULL
           )


## test inject numeric  
frame <- fct_var_dummy(
           frame = frame,
           name = "testnumeric",
           type = "numeric",
           list_opt = NULL,
           constraint = NULL
           )

## test inject date  
frame <- fct_var_dummy( 
          frame = frame,
          name = "testdate",
           type = "date",
           list_opt = NULL,
           constraint = NULL
           )

## Preview out out
knitr::kable(head(frame, 5))
```
  
```{r tests-fct_var_dummy}
test_that("fct_var_dummy works", {
  expect_true(inherits(fct_var_dummy, "function")) 
})
```
   
 
## fct_kobo_dummy
 
    
```{r function-fct_kobo_dummy}
#' fct_kobo_dummy
#' 
#' @description Automatically produce an dummy dataset in line with the structure 
#' of an XlsForm
#'  Making decisions about research design and analysis strategies is often difficult before data is collected,
#' because it is hard to imagine the exact form data will take.
#' This function helps imagine what data will look like before they collect it.
#' samplesize is set per defautl at 500 records
#'
#'  Supported Features: 
#' - Generate a data set  
#' - respects ODK structure "`relevant`" skip logic
#'    (Some advanced functionality such as "coalesce()" not covered)
#' - respects "`constraint`" 
#' - respects "`repeat`" adds ID column to link hierarchical data based on "`repeat_count`"
#'  This function is a rewriting of
#'     https://unhcr.github.io/koboloadeR/docs/reference/kobo_dummy.html 
#'   it also  build on  https://thinkr-open.github.io/fakir/ and
#'     https://docs.ropensci.org/charlatan/
#' 
#' @param  form file path of the XlsForm
#' @param n number of main records to be generated
#' @param nrepeat max random number of repeat records to be generated 
#'           when repeat_count is not mentionned 
#' @param file file as xlsx where to save the resulting data 
#' 
#' @importFrom kobocruncher kobo_dico
#' 
#' 
#' @return a data list with a series of dummy data 
#' 
#' @export
fct_kobo_dummy <- function(form,
                       n = 384,
                       file){
  
  dico <- kobocruncher::kobo_dico(xlsformpath = form)

  ## Get the variables to extract
  frame <- "main"
  
  conf <- data.frame(
      name <- dico[["variables"]] |>
        dplyr::filter(repeatvar ==  frame)  |> 
        dplyr::filter(! is.na(name))  |> 
        dplyr::filter(!(type %in% c("note", "begin_group", "end_group","begin_repeat", "end_repeat") ))  |> 
        dplyr::select(name),
      
      # dico[["variables"]]|>
      #   dplyr::filter(repeatvar ==  frame)  |> 
      #   dplyr::distinct(type)
      type <- dico[["variables"]]|>
        dplyr::filter(repeatvar ==  frame)  |> 
        dplyr::filter(! is.na(name))  |> 
        dplyr::filter(!(type %in% c("note", "begin_group", "end_group","begin_repeat", "end_repeat") ))  |>
        dplyr::select(type),
      
      ## pulling list options...
      list_opt <- dico[["variables"]] |>
        dplyr::filter(repeatvar ==  frame)  |> 
        dplyr::filter(! is.na(name))  |> 
        dplyr::filter(!(type %in% c("note", "begin_group", "end_group","begin_repeat", "end_repeat") ))  |>
        dplyr::select(list_name) ,
        #dplyr::left_join(modal, by = c("list_name")) |>
      #  dplyr::select( list_opt)
      
      
      constraint <- dico[["variables"]]|>
        dplyr::filter(repeatvar ==  frame)  |> 
        dplyr::filter(! is.na(name))  |> 
        dplyr::filter(!(type %in% c("note", "begin_group", "end_group","begin_repeat", "end_repeat") ))  |>
        dplyr::select(constraint)
  )
  
  ## We start with the generation of the main frame
  ## Build the main table and initiate it an index.....
  main <- dplyr::tibble(
        index = paste0( "ID-",
                      purrr::as_vector(
                            purrr::map(n, sample(LETTERS, 4)) |>
                            purrr::map(paste0, collapse = "")),
                          "-",
                          formatC(1:n, width = nchar(n) + 1, flag = "0")
                        ))
  names(main)[1] <- "_index"
  
  ## then apply fct_var_dummy interactively... 
  for(i in (1:nrow(conf)) ) {
   # i <- 1
    # cat(paste0(i, "-", conf[i, c("type")], "-", conf[i, c("name")],  "\n"))
  
  ## manage specific case when list name is not defined in ccoices but pulled from data..
  ## in such case we replace type by select_one by text
  this.type <-  conf[i, c("type")]
  this.name <-  conf[i, c("name")]
  this.listname <- conf[i , c("list_name")]
  this.constraint =  conf[i, c("constraint")] 
  
  ## cas there's no list matching..
  if( this.type %in% c("select_one", "select_multiple") & 
      !(this.listname %in% c( dico[["modalities"]] |> 
                              dplyr::pull(list_name))) ) { 
     this.listname <- NULL
     this.type <- "text"
     }
   
   main <- fct_var_dummy( 
          frame = main,
          name = this.name,
          type = this.type,
          list_opt =  c(dico[["modalities"]] |>
                         dplyr::filter(list_name == this.listname   )  |>
                         dplyr::pull(name) ),
          constraint =  this.constraint )
  }
    
  ## Still struggling with purrr
  # test  <- purrr::map(  main,
  #                       name,
  #                       type,
  #                       list_opt$list_opt ,
  #                       constraint ,
  #                     fct_var_dummy)
  
  ## TODO -- apply the relevance statement...
  ## define when the variable should exist based on other elements
  ## Need to convert the xlsform statement into R syntax
  # relevant <- dico[["variables"]]|>
  #   dplyr::filter(repeatvar == "main")  |> 
  #   dplyr::pull(relevant)
  
  ## replace  \" by ' 
  ## replace '=' by '=="
  ## replace '!==' by '!=" (to fix previsous replace)
  ## replace '${' '}'  with nothing..
  ## replace 'or'  with  '|'..
  ## replace 'and'  with '&'..
  
  ## Now store in the list...
  datalist <- list ( "main" = main) 

  ## treat cases with repeat table.. #####
  repeatvar <- dico[["variables"]] |> 
    dplyr::select(repeatvar)  |>
    dplyr::filter(repeatvar != "main")  |>
    dplyr::distinct()   |>
    dplyr::pull()   
  ## need to separate the different repeat elements wthin the form...
  for ( rep in repeatvar ) {
        
               confrep <- data.frame(
                    name <- dico[["variables"]] |>
                      dplyr::filter(repeatvar ==  rep)  |>  
                      dplyr::filter(! is.na(name))  |> 
                      dplyr::filter(!(type %in% c("note", "begin_group",
                                                  "end_group","begin_repeat", "end_repeat") ))  |>
                      dplyr::select(name),
                    
                    # dico[["variables"]]|>
                    #   dplyr::filter(repeatvar ==  rep)  |> 
                    #   dplyr::distinct(type)
                    type <- dico[["variables"]]|>
                      dplyr::filter(repeatvar ==  rep)  |> 
                      dplyr::filter(! is.na(name))  |> 
                      dplyr::filter(!(type %in% c("note", "begin_group",
                                                  "end_group","begin_repeat", "end_repeat") ))  |>
                      dplyr::select(type),
                    
                    ## pulling list options...
                    list_opt <- dico[["variables"]] |>
                      dplyr::filter(repeatvar ==  rep)  |> 
                      dplyr::filter(! is.na(name))  |> 
                      dplyr::filter(!(type %in% c("note", "begin_group",
                                                  "end_group","begin_repeat", "end_repeat") ))  |>
                      dplyr::select(list_name) ,
                      #dplyr::left_join(modal, by = c("list_name")) |>
                    #  dplyr::select( list_opt)
                    
                    
                    constraint <- dico[["variables"]]|>
                      dplyr::filter(repeatvar ==  rep)  |> 
                      dplyr::filter(! is.na(name))  |> 
                      dplyr::filter(!(type %in% c("note", "begin_group",
                                                  "end_group","begin_repeat", "end_repeat") ))  |>
                      dplyr::select(constraint)
                  )
            
            ## We start with the generation of the main frame
            ## Build the main table and initiate it an index.....
            repframe <- dplyr::tibble(
                  index = paste0( "ID-",
                                purrr::as_vector(
                                      purrr::map(n, sample(LETTERS, 4)) |>
                                      purrr::map(paste0, collapse = "")),
                                    "-",
                                    formatC(1:n, width = nchar(n) + 1, flag = "0")
                                  ))
            
            names(repframe)[1] <- "_parent_index"
            ## Apply now `_index`
            ## TODO -- check if we have a `repeat_count` to apply limitation..
            
            ## then apply fct_var_dummy interactively... 
            for(i in (1:nrow(confrep)) ) {
             # i <- 6
            #  cat(paste0(i, " in repeat -", rep, " ///", confrep[i, c("type")], "-", confrep[i, c("name")],  "\n"))
            
            ## manage specific case when list name is not defined in ccoices but pulled from data..
            ## in such case we replace type by select_one by text
            this.type <-  confrep[i, c("type")]
            this.name <-  confrep[i, c("name")]
            this.listname <- confrep[i , c("list_name")]
            this.constraint =  confrep[i, c("constraint")] 
            
            if(this.type %in% c("select_one", "select_multiple") & 
              !(this.listname %in% c( dico[["modalities"]] |>  
                                      dplyr::pull(list_name))) ) { 
               this.listname <- NULL
               this.type <- "text"
               }
             
             repframe <- fct_var_dummy( 
                    frame = repframe,
                    name = this.name,
                    type = this.type,
                    list_opt =  c(dico[["modalities"]] |>
                                   dplyr::filter(list_name == this.listname   )  |>
                                   dplyr::pull(name) ),
                    constraint =  this.constraint )
            }
        ## append to the repeat
        datalist[[rep]] <- repframe
      }
  return(datalist)
  }
```
  
```{r example-fct_kobo_dummy}
## generate dummy dataset for different form version

## CAPI
form <- system.file("RMS_CAPI_v2.xlsx", package = "IndicatorCalc")
datalist <- fct_kobo_dummy(form,
                       n = 1500,
                       file = NULL)
# openxlsx::write.xlsx(datalist, here::here("inst", "dummy_RMS_CAPI_v2.xlsx"))

form <- system.file("RMS_CAPI_v3.xlsx", package = "IndicatorCalc")
datalist <- fct_kobo_dummy(form,
                       n = 384,
                       file = NULL)
# openxlsx::write.xlsx(datalist, here::here("inst", "dummy_RMS_CAPI_v3.xlsx"))

## CATI
form <- system.file("RMS_CATI_v0.xlsx", package = "IndicatorCalc")
datalist <- fct_kobo_dummy(form,
                       n = 384,
                       file = NULL)
# openxlsx::write.xlsx(datalist, here::here("inst", "dummy_RMS_CATI_v0.xlsx"))

form <- system.file("RMS_CATI_v3.xlsx", package = "IndicatorCalc")
datalist <- fct_kobo_dummy(form,
                       n = 384,
                       file = NULL)
# openxlsx::write.xlsx(datalist, here::here("inst", "dummy_RMS_CATI_v3.xlsx"))
```
  
```{r tests-fct_kobo_dummy}
test_that("fct_kobo_dummy works", {
  expect_true(inherits(fct_kobo_dummy, "function")) 
})
```




# Data Wrangling

Each indicator calculation is based on predefined frame, variable name and variable value. Some data wrangling is therefore required before performing the calculations.

The packages comes with tool to support this task. The original data can be transformed with the function fct_re_map(). The mapper object is build with the `fct_build_map()` function, which require 2 files: 

 * `IndicatorRequirementFile`   thi files is created from the orginal template and indicator scripts. It creates a mapping between question variables and indicator variables.

* `mappingfile`  this one is created once and is designed to double check that the mapping can actually be performed. To obtain this file, we Apply fuzzy matching `fct_var_mapping()` to map within a specified XlsForm the expected variables for indicator calculation. The output is a convenient excel file that will need to be manually revised. The process is very similar than data cleaning with a cleaning log as implemented within [{cleaningtools}](https://edouard-legoupil.github.io/cleaningtools/)
 
The data wrangling is then done with the function `fct_re_map()` to obtain the data in the exact format expected by the indicator calculation functions

Before doing indicator calculation, `fct_check_map()` checks that standard frame/variable/modalities are present in the dataset. 

## fct_var_mapping
    
```{r function-fct_var_mapping}
#' fct_var_mapping
#' 
#' Create a diff to identify the mapping between expected variables / modalities and 
#' what is has been configured in a specific xlsform. The function use a fuzzy matching
#'  process to identify the best and second best match process... 
#'  It generates an excel file ready for manual review and that can be used as an input 
#'  for the next function in the pipeline fct_build_map()
#'  
#'  When you open the excel, filter for all match where the matching_index_best is different than 0
#'  
#'  If you can confirm the match, manually set it to 0 so that the matching can be confirmed.
#'  If the matching is not the expected one you may take the second best match, and if correct,
#'  paste it and set the index to 0
#' 
#' @param xlsformpath path to the xlsform
#' @param IndicatorRequirementFile path to the file where the standard mapping is depending on form version
#' @param mappingfile_out path to file to out the mapping
#' 
#' @import stringdist
#' @import dplyr
#' 
#' @return a list with the best mapping...
#' 
#' @export
fct_var_mapping <- function(xlsformpath,
                            IndicatorRequirementFile,
                            mappingfile_out){
  ## Pulling Comparison base ######
  IndicMap <- readxl::read_excel(IndicatorRequirementFile )
  dico <- kobocruncher::kobo_dico(xlsformpath) 
  
 # Comparing variables ##########
 # names(IndicMap)
  varMapIndic <- IndicMap |>
    dplyr::select(QuestionVar, label, type) |>
    dplyr::distinct() |>
     tibble::as_tibble()
  ## Comparing based on variable name          
  vec1 <- varMapIndic$QuestionVar
  
  ## Now taking the form...
   varMapForm <- dico[["variables"]] |>
      # names(varMapForm)
     # levels(as.factor(varMapForm$type))
    dplyr::select(name, name_or, type, label) |>
    dplyr::filter(type %in% c("integer","multiple", "select_multiple", "select_one")) |>
    dplyr::distinct() |>
     tibble::as_tibble()
  ## Comparing based on variable name 
  vec2 <- varMapForm$name_or
  
  # Initialize an empty dataframe to store the results
  result_match <- data.frame(
    Indic = character(),
    best_match = character(),
    matching_index_best = integer(),
    second_best = character(),
    matching_index_second_best = integer(),
    stringsAsFactors = FALSE
  )
  # Loop through each element in the first vector
  for (i in seq_along(vec1)) {
    #i <- 1
    # Calculate Levenshtein distances between the current element and all elements in the second vector
    distances <- stringdist::stringdistmatrix(vec1[i], vec2)
    
    # Find the index of the minimum distance (best match)
    best_match_index <- which.min(distances)
    
    # Sort distances to find the second best match
    sorted_distances <- sort(distances)
    second_best_match_index <- which(distances == sorted_distances[2])
    thismatch <- data.frame(
        Indic = vec1[i],
        best_match = vec2[best_match_index],
        matching_index_best = distances[best_match_index],
        second_best = vec2[second_best_match_index[1]],
        matching_index_second_best = sorted_distances[2]
      )
    # Append the results to the dataframe
    result_match <- rbind( result_match, thismatch )
  }
  ## merge this with type and label
  result_matchInd <- varMapIndic |>
                  dplyr::left_join(result_match, by = c("QuestionVar"="Indic" )) |>
                  dplyr::left_join(varMapForm |>
                                   dplyr::rename( best_name = "name", 
                                                    best_type = "type", 
                                                    best_label = "label"), 
                                   by = c("best_match"="name_or" ))  |>
                  dplyr::left_join(varMapForm |>
                                   dplyr::rename( second_name = "name", 
                                                    second_type = "type", 
                                                    second_label = "label"), 
                                   by = c("second_best"="name_or" ))  |>
    dplyr::select(QuestionVar, label, type, 
                  best_match, matching_index_best, best_name, best_type, best_label,
                  second_best, matching_index_second_best, 
                  second_name, second_type, second_label)
  
 # Comparing modalities ##########
 # names(IndicMap)
  varMapMod <- IndicMap |>
    dplyr::select(QuestionVar, list_name, name_mod, label_mod) |>
    dplyr::mutate( mod = paste0(QuestionVar, ".", name_mod)) |>
    dplyr::distinct() |>
     tibble::as_tibble()
  ## Comparing based on variable name          
  vec1 <- varMapMod$mod
  
  ## Now taking the form...
   varMapFormMod1 <- 
      dico[["variables"]] |>
      dplyr::filter(type %in% c( "select_multiple", "select_one")) |>
      dplyr::select( name_or, type, list_name) |>
      dplyr::rename(name_var = "name_or") |>
     ## retain only modalities from the var matching
     dplyr::filter( name_var %in% result_match$best_match |
                      name_var %in% result_match$second_best )
   
    varMapFormMod2 <- dico[["modalities"]] |>
      # names(varMapFormMod)
     # levels(as.factor(varMapForm$type))
    dplyr::select(list_name, name, label)|>
     ## retain only modalities from the var matching
     dplyr::filter( list_name %in%  varMapFormMod1$list_name )
   
   varMapFormMod3 <- varMapFormMod2 |>
    dplyr::left_join(  varMapFormMod1  ,
      by = c( "list_name"), 
      relationship  = "many-to-many") |>
    dplyr::mutate( mod = paste0(name_var, ".", name)) |>
    dplyr::distinct() |>
     tibble::as_tibble()
  ## Comparing based on variable name 
  vec2 <- varMapFormMod3$mod
  
  # Initialize an empty dataframe to store the results
  result_match <- data.frame(
    Indic = character(),
    best_match = character(),
    matching_index_best = integer(),
    second_best = character(),
    matching_index_second_best = integer(),
    stringsAsFactors = FALSE
  )
  # Loop through each element in the first vector
  for (i in seq_along(vec1)) {
    #i <- 1
    # Calculate Levenshtein distances between the current element and all elements in the second vector
    distances <- stringdist::stringdistmatrix(vec1[i], vec2)
    
    # Find the index of the minimum distance (best match)
    best_match_index <- which.min(distances)
    
    # Sort distances to find the second best match
    sorted_distances <- sort(distances)
    second_best_match_index <- which(distances == sorted_distances[2])
    thismatch <- data.frame(
        Indic = vec1[i],
        best_match = vec2[best_match_index],
        matching_index_best = distances[best_match_index],
        second_best = vec2[second_best_match_index[1]],
        matching_index_second_best = sorted_distances[2]
      )
    # Append the results to the dataframe
    result_match <- rbind( result_match, thismatch )
  }
  ## merge this with type and label
  result_matchMod <- varMapMod |>
                  dplyr::left_join(result_match, by = c("mod"="Indic" )) |>
                  dplyr::left_join(varMapFormMod3 |>
                                   dplyr::rename( best_name = "name", 
                                                    best_type = "type", 
                                                    best_list_name = "list_name", 
                                                    best_label = "label"), 
                                   by = c("best_match"="mod" ))  |>
                  dplyr::left_join(varMapFormMod3 |>
                                   dplyr::rename( second_name = "name", 
                                                  second_type = "type", 
                                                  second_list_name = "list_name", 
                                                  second_label = "label"), 
                                   by = c("second_best"="mod" ))  |>
    # dput( names(result_matchMod))
    dplyr::select(QuestionVar, list_name, name_mod, label_mod, mod, 
                  best_match, matching_index_best,
                  best_list_name, best_name, best_label, best_type,
                  second_best, matching_index_second_best, 
                  second_list_name, second_name, second_label, second_type)                 
  results <- list(
    result_matchInd = result_matchInd,
    result_matchMod = result_matchMod
    
  )
  
  ## Return the excel file
  if(!(is.null(mappingfile_out))){
    openxlsx2::write_xlsx(results,
                      file = mappingfile_out, 
                      overwrite = T,
                      na.strings = "")
  }
  
  
  # Return the results
  return(results)
}


```
  
```{r example-fct_var_mapping}
# Test the function
form <- system.file("RMS_CAPI_v2.xlsx", package = "IndicatorCalc")
IndicatorRequirementFile <- system.file("RMS_CAPI_v2_mapper.xlsx", package = "IndicatorCalc")
# Get the map to revise
mapper <- fct_var_mapping(xlsformpath = form,
                          IndicatorRequirementFile = IndicatorRequirementFile,
                       mappingfile_out = tempfile())
                         #      here::here("inst", "RMS_CAPI_v2_mapping.xlsx"))
```
  
```{r tests-fct_var_mapping}
test_that("fct_var_mapping works", {
  expect_true(inherits(fct_var_mapping, "function"))
})
```


## fct_build_map
    
```{r function-fct_build_map}
#' fct_build_map
#' 
#' Quick helper to reformat the data from the mapping file into the mapping file
#' to use  with each indicator calculation. T
#' 
#' his needs to be done in two steps: 
#' one for `ind` for individual level and 
#' one for `main` for household level
#' 
#' @param mappingfile full path to the xlsx file with the revise variable mapping generated with `fct_var_mapping()`
#' 
#' @param IndicatorRequirementFile path to the file where the standard mapping is depending on form version
#' 
#' @param thisMeasureLevel can be `ind` for individual level or `main` for household level
#' 
#' @import readxl
#' @import dplyr
#' 
#' @return a list 
#' 
#' @export
fct_build_map <- function(mappingfile,
                          IndicatorRequirementFile,
                          thisMeasureLevel){
  
  IndicMap <- readxl::read_excel( IndicatorRequirementFile)
  ## Merge the map...
  MeasureLevelQ <- IndicMap |>
               dplyr::select(MeasureLevel, QuestionVar)  |>
               dplyr::filter(MeasureLevel == thisMeasureLevel)|>
               dplyr::distinct()
  
  revisemapIndic <- readxl::read_excel( mappingfile, 
    sheet = "result_matchInd")
  
   revisemapIndic2 <- MeasureLevelQ |>
                dplyr::left_join(revisemapIndic, by = c("QuestionVar") ) |>
                dplyr::rename(#QuestionVar, 
                              #label, 
                              mappattern = "best_name") |>
                dplyr::select(QuestionVar, label, mappattern)|>
               dplyr::distinct()
   
   # names( IndicMap)
   # names(revisemapIndic2)  
   # names(revisemapMod)   
   
   
  revisemapMod <- readxl::read_excel( mappingfile, 
    sheet = "result_matchMod")
  revisemapMod2 <- MeasureLevelQ  |>
                dplyr::left_join(revisemapMod, by = c("QuestionVar") ) |>
                dplyr::rename(#variable = "QuestionVar", 
                             # label= "label_mod" ,   
                             # standard = "name_mod" , 
                              map = "best_name") |>
                dplyr::select(QuestionVar, label_mod, name_mod, map)
   
 
   
  filemap <- tempfile()
  filemaplab <- tempfile()
  #filemap <- "dev/test1.R"
  if (file.exists(filemap)) file.remove(filemap) 
     
     cat( paste0( "thismapper = list("), file = filemap , sep = "\n", append = TRUE)
     cat( paste0( "           hierarchy = \"", thisMeasureLevel,"\","), file = filemap , sep = "\n", append = TRUE)
     
 
     ## Mapping variables
     thisvar <- revisemapIndic2 |>  
                    dplyr::select(QuestionVar, label, mappattern) |> 
                    dplyr::distinct()  
     cat( paste0( "          variablemap = data.frame("), file = filemap , sep = "\n", append = TRUE)
     cat( paste0( "            label = "), file = filemap , sep = "\n", append = TRUE)
     ## Looping around labels
          dput( thisvar |> dplyr::pull(label) , file = filemaplab )
          file_str <- paste(readLines(filemaplab), collapse="\n")
     cat( paste0(file_str), file = filemap , sep = "\n", append = TRUE)
     cat( paste0( "              ,"), file = filemap , sep = "\n", append = TRUE)
     cat( paste0( "            mappattern = "), file = filemap , sep = "\n", append = TRUE)
     ## Looping around mappattern
          dput( thisvar |> dplyr::pull(mappattern) , file = filemaplab )
          file_str <- paste(readLines(filemaplab), collapse="\n")
     cat( paste0(file_str), file = filemap , sep = "\n", append = TRUE)
     cat( paste0( "              ,"), file = filemap , sep = "\n", append = TRUE)
     cat( paste0( "            variable =  "), file = filemap , sep = "\n", append = TRUE)
     ## Looping around  variable
      dput( thisvar |> dplyr::pull(QuestionVar), file = filemaplab )
          file_str <- paste(readLines(filemaplab), collapse="\n")
     cat( paste0(file_str), file = filemap , sep = "\n", append = TRUE)
     cat( paste0( "              ),"), file = filemap , sep = "\n", append = TRUE)
    
      ## Mapping modality
     thismod <- revisemapMod2 |> 
                    dplyr::select(QuestionVar, label_mod, name_mod, map) |> 
                    dplyr::filter(! (is.null(name_mod)) ) |> 
                    dplyr::distinct()  
     cat( paste0( "          modalitymap = data.frame("), file = filemap , sep = "\n", append = TRUE)
     cat( paste0( "            variable =  "), file = filemap , sep = "\n", append = TRUE)
     ## Looping around variable for modalities
      dput( thismod |> dplyr::pull(QuestionVar) , file = filemaplab )
          file_str <- paste(readLines(filemaplab), collapse="\n")
     cat( paste0(file_str), file = filemap , sep = "\n", append = TRUE)
     cat( paste0( "               ,"), file = filemap , sep = "\n", append = TRUE)
     cat( paste0( "            label =  "), file = filemap , sep = "\n", append = TRUE)
     ## Looping around labels for modalities
      dput( thismod |> dplyr::pull(label_mod) , file = filemaplab )
          file_str <- paste(readLines(filemaplab), collapse="\n")
     cat( paste0(file_str), file = filemap , sep = "\n", append = TRUE)
     cat( paste0( "               ,"), file = filemap , sep = "\n", append = TRUE)
     cat( paste0( "            map =  "), file = filemap , sep = "\n", append = TRUE)
     ## Looping around labels for modalities
      dput( thismod |> dplyr::pull(map) , file = filemaplab )
          file_str <- paste(readLines(filemaplab), collapse="\n")
     cat( paste0(file_str), file = filemap , sep = "\n", append = TRUE)
     cat( paste0( "               ,"), file = filemap , sep = "\n", append = TRUE)
     cat( paste0( "            standard =  "), file = filemap , sep = "\n", append = TRUE)
     ## Looping around standard for modalities
      dput( thismod |> dplyr::pull(name_mod) , file = filemaplab )
          file_str <- paste(readLines(filemaplab), collapse="\n")
     cat( paste0(file_str), file = filemap , sep = "\n", append = TRUE)
     cat( paste0( "              ))"), file = filemap , sep = "\n", append = TRUE) 
     
    source(filemap)
     
 return(thismapper)
}
```
  
```{r example-fct_build_map}
mappingfile <- system.file("RMS_CAPI_v2_mapping.xlsx", 
                           package = "IndicatorCalc")

IndicatorRequirementFile <- system.file("RMS_CAPI_v2_mapper.xlsx", 
                           package = "IndicatorCalc")

mappermain <- fct_build_map(mappingfile = mappingfile, 
                            IndicatorRequirementFile = IndicatorRequirementFile,
                            thisMeasureLevel = "main")

mapperind <- fct_build_map(mappingfile = mappingfile,
                            IndicatorRequirementFile = IndicatorRequirementFile,
                           thisMeasureLevel = "ind")

```
  
```{r tests-fct_build_map}
test_that("fct_build_map works", {
  expect_true(inherits(fct_build_map, "function")) 
})
```
  



## fct_get_all_variable_names
    
```{r function-fct_get_all_variable_names}
#' fct_get_all_variable_names
#' 
#' Generate a map of all variables within the datalist obtained from RIDL - 
#'   standard Kobo extract in Excel
#' 
#' @param datalist A list with all hierarchical data frame for a survey data set.
#'    format is expected to match the Excel export synchronized from kobo to RILD
#'    and loaded with  kobocruncher::kobo_data() 
#' 
#' @return dataframe with variables and list member names 
#' 
#' @importFrom purrr imap list_rbind
#' @importFrom tibble tibble as_tibble_col
#' @importFrom tidyr unnest
#' 
#' @keywords internal
#' 
#' @export
fct_get_all_variable_names <- function(datalist){
  
    dico <- purrr::imap(datalist,
       function(x, y) tibble::tibble(df = y,
                      vars = tibble::as_tibble_col(names(x))) |> 
         tidyr::unnest(vars)) |>
       purrr::list_rbind()
    
    return(dico)
    
}
```
  
```{r example-fct_get_all_variable_names}
datalist <- kobocruncher::kobo_data( system.file("demo_data.xlsx", #"test.xlsx", 
                                             package = "IndicatorCalc"))
varname <-   fct_get_all_variable_names(datalist = datalist)
head(varname, 10)
```
  
```{r tests-fct_get_all_variable_names}
test_that("fct_get_all_variable_names works", {
  expect_true(inherits(fct_get_all_variable_names, "function")) 
})
```

## fct_re_map
    
```{r function-fct_re_map}
#' fct_re_map
#' 
#' Take a list with a hierarchical survey as an entry - use another list to remap
#' variables and modalities for specific questions 
#' @param datalist A list with all hierarchical data frame for a survey data set.
#'    format is expected to match the Excel export synchronized from kobo to RILD
#'    and loaded with  kobocruncher::kobo_data() 
#'                    
#' @param mapper a list providing the mapping of the variables used for the 
#' calculation - this mapper is potentially to be adjusted in relation with deviation
#' between the the standard XlsForm and the contextualized dataset
#' 
#' @importFrom dplyr filter row_number mutate pull
#' @importFrom cli cli_alert_info
#' @return datalist
#' 
#' @export
fct_re_map <- function(datalist, mapper){
  
   varname <-   fct_get_all_variable_names(datalist)

   ## Loop around the variables within mapper
   for ( i in 1:nrow(mapper[["variablemap"]]) ) {
     # i <- 4 
     thisvar <-  mapper[["variablemap"]][["variable"]][[i]]
     thismappattern <-  mapper[["variablemap"]][["mappattern"]][[i]]
     
     ## get the list member and variable name based on pattern matching
     thismatch <- varname |>
                 dplyr::mutate( match = grepl(pattern = thismappattern ,
                                              x = value)) |>
                 dplyr::filter( match == TRUE ) 
     
     ## In case multiple pattern match take the first one
     if ( nrow(thismatch) > 1) {
       cli::cli_alert_info(paste0( thisvar ,
   " variable has more than one variable pattern match in the dataset. We will take the first one but good to check... \n")) 
       thismatch <- thismatch |> dplyr::filter( dplyr::row_number() == 1)
       }
     
     ## If matches push!
    if ( nrow(thismatch) == 0 ) { 
      cli::cli_alert_info(paste0( thisvar ,
           " variable pattern was not found in the dataset.\n"))
      }  else {
     ## Now  transform
     datalist[[mapper[["hierarchy"]] ]] [[ thisvar ]]  <- 
        datalist[[thismatch |> dplyr::pull(df) ]][[thismatch |> dplyr::pull(value)]]
       
    ## Apply modalities transformation
    mod <- mapper[["modalitymap"]] |>
         dplyr::filter( variable == thisvar ) 
    
    datalist[[mapper[["hierarchy"]] ]] [[ thisvar ]] <- plyr::mapvalues(
      x = datalist[[mapper[["hierarchy"]] ]] [[ thisvar ]] ,
      from = mod[["map"]],
      to=  mod[["standard"]])
    
    newlev <- paste(
      levels(as.factor(datalist[[mapper[["hierarchy"]] ]] [[ thisvar ]] )),  
      collapse = ', ')  
    
    ## Inform user
    cat(paste0("Mapped levels for ", 
               thisvar, " are now: ", 
               newlev,
               "\n"))
    rm(thisvar, newlev)
     }
   }
   return(datalist)
    
}
```
  
```{r example-fct_re_map}
mapper = list(
            hierarchy = "main",
            variablemap = data.frame(
              label = c("Does this household use anything for lighting?",
                        "What source of electricity is used most of the time in this household?"),
              variable = c("LIGHT01", 
                           "LIGHT03"),
              mappattern = c("LIGHT01", 
                           "LIGHT03") ),
            modalitymap = data.frame(
              variable = c( "LIGHT01", 
                            "LIGHT03", "LIGHT03", "LIGHT03"),
              label = c( "yes",
                "No electricity in household", "Other, specify", "Don\'t know"),
              standard = c( "1",
                           "1", "96", "98"),
              map = c("yes",
                      "Noelec", "Other", "Dontknow")
            )
          )


## One variable is not correctly 
datalist <- list(mainhousehold = data.frame(
                group.LIGHT01 = c("yes",  "yes",  "no", "yes",  "yes",
                                  "no", "yes",  "yes",  "yes"),
                group.LIGHT03 = c("Noelec", "Other", "Dontknow", "Noelec", "Other",
                                  "Dontknow", "Nuclear", "Other", "Dontknow"))
             )
datalist <- fct_re_map(datalist = datalist, mapper = mapper )

#fct_check_map(datalist = datalist, mapper = mapper )

## Now testing on a full remap...
## Dummy data created with fct_kobo_dummy
datalist <- kobocruncher::kobo_data( system.file("dummy_RMS_CAPI_v2.xlsx",
                                                 package = "IndicatorCalc"))

## Mapping file created from Dummy data  
mappingfile <- system.file("RMS_CAPI_v2_mapping.xlsx", 
                           package = "IndicatorCalc")

IndicatorRequirementFile <- system.file("RMS_CAPI_v2_mapper.xlsx", 
                           package = "IndicatorCalc")

## and now we remap both required variables for main and ind
mappermain <- fct_build_map(mappingfile = mappingfile, 
                            IndicatorRequirementFile = IndicatorRequirementFile,
                            thisMeasureLevel = "main")
datalist <- fct_re_map(datalist = datalist, mapper = mappermain )

mapperind <- fct_build_map(mappingfile = mappingfile, 
                            IndicatorRequirementFile = IndicatorRequirementFile,
                           thisMeasureLevel = "ind")
datalist <- fct_re_map(datalist = datalist, mapper = mapperind )



## Writing this in the installation folder of the packages to run all examples
# openxlsx::write.xlsx( list ( main = as.data.frame(datalist[["main"]]),
#                              ind = as.data.frame(datalist[["ind"]]) ),
#                       here::here("inst","dummy_RMS_CAPI_v2_mapped.xlsx"))

```
  
```{r tests-fct_re_map}
test_that("fct_re_map works", {
  expect_true(inherits(fct_re_map, "function")) 
})
```


## fct_check_map

```{r function-fct_check_map}
#' fct_check_map
#' 
#' This functions checks if the standard variables and modalities included in the mapper are
#' actually present in the datalist with the same exact name - this is actually
#' usually not the case as the standard format to save kobo dataset in xlsx includes 
#' group in the variable name. 
#' This function is used internally in each indicator function as an eror catcher before
#' performing calculations... 
#' 
#' @param datalist A list with all hierarchical data frame for a survey data set.
#'    format is expected to match the Excel export synchronized from kobo to RILD
#'    and loaded with  kobocruncher::kobo_data() 
#'                    
#' @param mapper a list providing the mapping of the variables used for the 
#' calculation - this mapper is potentially to be adjusted in relation with deviation
#' between the the standard XlsForm and the contextualized dataset
#' 
#' 
#' @return boolean flag TRUE or FALSE indicating if we can go forward for the indicator calculation
#' 
#' @import cli
#' 
#' @export
fct_check_map <- function(datalist, mapper){
  # rm(check )
   check <- data.frame( check = c(""))
   ## Loop around the variables within mapper
   for ( i in 1:nrow(mapper[["variablemap"]]) ) {
     # i <- 3
     thisvar <-  mapper[["variablemap"]][["variable"]][[i]]
     
    if ( is.null( datalist[[mapper[["hierarchy"]] ]] [[ thisvar ]] ) ) 
      
    {cli::cli_alert_danger(paste0( thisvar ," not found in the dataset.\n"))
       check <- rbind(  check , check = c(FALSE))
      }
     else {
    ## If present check modalities
    mod <- mapper[["modalitymap"]] |>
         dplyr::filter( variable == thisvar ) |>
         dplyr::pull(standard)
    ## If numeric - mod is NA
    if( anyNA(mod) ) { 
      
     cli::cli_alert_success(paste0( thisvar ," \n")) 
     check <- rbind(  check , check = c(TRUE))
      } else {
      
   if( any(levels(as.factor(datalist[[mapper[["hierarchy"]] ]] [[ thisvar ]])) %in%  mod ) )
      { 
     cli::cli_alert_success(paste0( thisvar ," \n")) 
     check <- rbind(  check , check = c(TRUE))
     } else {
    cli::cli_alert_info(paste0( thisvar , " misses responses options among : ", mod)) 
       check <- rbind(  check , check = c(FALSE)) }
     }
    }
   }
   ## Check if have any fasel
   finalcheck <- if( FALSE %in% check$check ) { paste0(FALSE)}  else { paste0(TRUE)}
   
   return(finalcheck)
}
```
  
```{r example-fct_check_map}
## below is the mapper to chck if we have the variables to calculate the 
# electricity subindicators within impact 2.2
mapper = list(
            hierarchy = "main",
            variablemap = data.frame(
              label = c(
"Does this household use anything for lighting?",
"What source of electricity is used most of the time in this household?"),
              variable = c("LIGHT01", 
                           "LIGHT03") ),
            modalitymap = data.frame(
              variable = c( "LIGHT01", 
                            "LIGHT03", "LIGHT03", "LIGHT03"),
              label = c( "yes",
          "No electricity in household", "Other, specify", "Don\'t know"),
              standard = c( "1",
                           "1", "96", "98")
            )
          )

## Correct format
data <- list(main = data.frame(
                LIGHT01 = c("1",  "1",  "0", "1",  "1",  "0", "1",  "1",  "1"),
                LIGHT03 = c("1", "96", "98", "1", "96", "98", "0", "96", "98"))
             )
check <- fct_check_map(datalist = data, mapper = mapper )
check

## One variable is not correctly 
data <- list(main = data.frame(
                LIGHT01 = c("1",  "1",  "0", "1",  "1",  "0", "1",  "1",  "1"),
                LIGH03 = c("1", "96", "98", "1", "96", "98", "0", "96", "98"))
             )
check <- fct_check_map(datalist = data, mapper = mapper )
check 

## The first variable does not include a single 1...
data <- list(main = data.frame(
                LIGHT01 = c("0",  "0",  "0", "0",  "0",  "0", "0",  "0",  "0"),
                LIGHT03 = c("1", "96", "98", "1", "96", "98", "0", "96", "98"))
             )
check <- fct_check_map(datalist = data, mapper = mapper )
check 
```
  
```{r tests-fct_check_map}
test_that("fct_check_map works", {
  expect_true(inherits(fct_check_map, "function")) 
})
```

# Plot

## fct_plot_indic_donut
    
```{r function-fct_plot_indic_donut}
#' fct_plot_indic_donut
#' 
#' Wrapper for a summary chart for indicator - allows to add hint, source,  icon
#'  and interpretation threshold if available
#'  
#'  @param indicator vector
#'  @param subtitle_chart  subtitle for the chart
#'  @param caption_chart  caption for the chart
#'  @param ordered_threhold  vector with the different threshold 
#'    (green, orange, red)
#'  @param iconunicode  unicode value for fontawesome --- 
#'              see https://fontawesome.com/search?o=r&m=free
#' 
#' 
#' @return ggplot2 object 
#' 
#' @import ggplot2 
#' @importFrom  unhcrthemes scale_fill_unhcr_d theme_unhcr
#' @importFrom ggforce geom_arc_bar
#' @importFrom ggtext geom_richtext
#' 
#' @export
fct_plot_indic_donut <- function(indicator,
                                 subtitle_chart = NULL,
                                 caption_chart = NULL,
                                 ordered_threhold = NULL,
                                 iconunicode = "f496"){
  
  
#   # Loading required packages
# library(unhcrthemes)
# library(tidyverse)
# library(ggtext)
# library(ggforce)

# Loading data
#indicator <- datalist[["main"]]$shelter
 if (is.null(indicator)) {
        cat("No value was supplied for plotting...")
      } else { 
  
df2 <-sjmisc::frq(indicator, show.na = FALSE)[[1]]
#df2$label <- factor(df2$label, levels = c( "Yes","No"))

# Plot
plot <- ggplot2::ggplot(df2) +
  ggforce::geom_arc_bar(
    ggplot2::aes( 
        x0 = 0, y0 = 0,
        r0 = 0.6, r = 1,
        amount = raw.prc,
        fill = label  ),
  stat = "pie",  size = 1,  color = "#FFFFFF"  ) +
  
  ggtext::geom_textbox(
    x = 0,  y = 0,
    label = paste0(
      "<span style=\'font-family: \"Font Awesome 6 Free Solid\" font-size:44pt\'>&#x",
      iconunicode,";</span><br><span style=\'font-size:16pt\'>",
      sjlabelled::get_label(indicator) ,
      "</span><br><strong> ",
      round(df2 |>
              dplyr::filter(val == 1) |>
              dplyr::pull(raw.prc), 2),
      "%</strong>"),
    size = 16 ,  
    
   # hjust = 0, vjust = 1,
    halign = 0.5, # centered text
    width = grid::unit(0.60, "npc"), # 73% of plot panel width
    box.colour = NA,
    fill = NA#,  
   # label.color = NA  
    ) +
  
  ggplot2::labs( #title = sjlabelled::get_label(x ), 
       subtitle = subtitle_chart, 
        caption = caption_chart ) +
  
  ggplot2::scale_x_continuous(expand = ggplot2::expansion(c(0.3, 0.5))) +
  unhcrthemes::scale_fill_unhcr_d( palette = "pal_unhcr", direction = -1) +
  
  unhcrthemes::theme_unhcr( grid = FALSE,  axis = FALSE,
    axis_title = FALSE, axis_text = FALSE, legend = FALSE
  )

#plot

return(plot)
}
    
}
```
  
```{r example-fct_plot_indic_donut, fig.height=3, fig.width=3}
test <- data.frame(
  shelter = c(rbinom(20, 1, 0.5), NA, NA, NA, NA, NA, NA) ) |> 
  dplyr::mutate( shelter = 
  labelled::labelled( shelter,
    labels = c( "Yes" = 1, "No" = 0),
label = "Access to adequate shelter also testing a long title to see if it wraps well")) 
  
fct_plot_indic_donut(indicator = test$shelter,
                     subtitle_chart = NULL,
                     caption_chart = NULL,
                     ordered_threhold = NULL,
                     iconunicode = "e54f") 

## test no value
test2 <- NULL

fct_plot_indic_donut(indicator = test2,
                     subtitle_chart = NULL,
                     caption_chart = NULL,
                     ordered_threhold = NULL,
                     iconunicode = "e54f") 
```
  
```{r tests-fct_plot_indic_donut}
test_that("fct_plot_indic_donut works", {
  expect_true(inherits(fct_plot_indic_donut, "function")) 
})
```
  

## fct_plot_rbm_sdg - SDG Comparison
    
```{r function-fct_plot_rbm_sdg}
#' @title Plot SDG Indicator for a country
#' @description The function is designed to help the interpretation of survey 
#'  results by providing a comparison guidelines. It displays a chart to have a 
#'  base of comparison when analyzing the results of UNHCR of UNHCR Result monitoring
#'  survey. It pulls the values published within the UN Registry of SDG Indicator values
#'  The function includes a mapping table between RBM/RMS and SDG and 
#'  extract the data from https://unstats.un.org/SDGAPI/swagger/ using the package SDGsR
#'  https://drmattg.github.io/SDGsR/articles/Introduction_to_SDGsR.html
#'               devtools::install_github("DrMattG/SDGsR", dependencies = TRUE)
#' @param country iso3 code for the country (easier to recall than the M49 used in the API)
#' @param rbm  the RBM variable name - that can match SDG 
#' @param years  years to filter the chart - for instance c(2000,2022)
#' 
#' @import ggplot2
#' @importFrom SDGsR get_indicator
#' @importFrom countrycode countrycode
#' @importFrom janitor clean_names
#' @importFrom stringr str_replace
#' 
#' @return a ggplot2 object
#' @export
fct_plot_rbm_sdg <- function( country = "BRA", 
                      rbm = "outcome16_2",
                      years = c(2000, 2022)) {
  require(ggplot2)
  require(dplyr)
  
  ## Below is a mapping table between indicators codes for UNHCR and SDG...
sdg_rbm <-  structure(list(
  indicator = c("1.4.1", "3.8.1", "16.9.1", "7.1.2", 
                "7.1.1", "3.1.2", "6.1.1", "6.2.1", 
                "8.10.2", "8.5.2", "1.4.2", "1.3.1", "16.1.4"), 
               
  SDG_indic = c(
    "1.4.1 Proportion of population living in households with access to basic services", 
  "3.8.1 Coverage of essential health services (defined as the average coverage of 
  essential services based on tracer interventions that include reproductive, maternal, 
  newborn and child health, infectious diseases, non-communicable diseases and service 
  capacity and access, among the general and the most disadvantaged population)", 
  "16.9.1 Proportion of children under 5 years of age whose births have been registered 
  with a civil authority, by age", 
  "7.1.2 Proportion of population with primary reliance on clean fuels and technology", 
  "7.1.1 Proportion of population with access to electricity", 
  "3.1.2 Proportion of births attended by skilled health personnel", 
  "6.1.1 Proportion of population using safely managed drinking water services", 
  "6.2.1 Proportion of population using (a) safely managed sanitation services and (b) 
  a hand-washing facility with soap and water", 
  "8.10.2 Proportion of adults (15 years and older) with an account at a bank or other
  financial institution or with a mobile-money-service provider", 
  "8.5.2 Unemployment rate, by sex, age and persons with disabilities", 
  "1.4.2 Proportion of total adult population with secure tenure rights to land, (a)
  with legally recognized documentation, and (b) who perceive their rights to land as 
  secure, by sex and type of tenure", 
  "1.3.1 Proportion of population covered by social protection floors/systems, by sex,
  distinguishing children, unemployed persons, older persons, persons with disabilities,
  pregnant women, newborns, work-injury victims and the poor and the vulnerable", 
  "16.1.4 Proportion of population that feel safe walking alone around the area they live"), 
  
  RMS = c("impact2_2", "impact2_3", "outcome1_2", "outcome8_2", 
          "outcome9_2", "outcome10_2", "outcome12_1", "outcome12_2", "outcome13_1", 
          "outcome13_3", "outcome16_1", "outcome16_2", "impact3_3"),
  
  target = c("1.4", 
  "3.8", "16.9", "7.1", "7.1", "3.1", "6.1", "6.2", "8.10", "8.5", 
  "1.4", "1.3", "16.1"),
  
  description = c("By 2030, ensure that all men and women, in particular the poor and 
                  the vulnerable, have equal rights to economic resources, as well as 
                  access to basic services, ownership and control over land and other
                  forms of property, inheritance, natural resources, appropriate new 
                  technology and financial services, including microfinance", 
  "Achieve universal health coverage, including financial risk protection, access to
  quality essential health-care services and access to safe, effective, quality and
  affordable essential medicines and vaccines for all", 
  "By 2030, provide legal identity for all, including birth registration", 
  "By 2030, ensure universal access to affordable, reliable and modern energy services", 
  "By 2030, ensure universal access to affordable, reliable and modern energy services", 
  "By 2030, reduce the global maternal mortality ratio to less than 70 per 100,000 live births", 
  "By 2030, achieve universal and equitable access to safe and affordable drinking water for all", 
  "By 2030, achieve access to adequate and equitable sanitation and hygiene for all and
  end open defecation, paying special attention to the needs of women and girls and those
  in vulnerable situations", "Strengthen the capacity of domestic financial institutions 
  to encourage and expand access to banking, insurance and financial services for all", 
  "By 2030, achieve full and productive employment and decent work for all women and men,
  including for young people and persons with disabilities, and equal pay for work of equal value", 
  "By 2030, ensure that all men and women, in particular the poor and the vulnerable, 
  have equal rights to economic resources, as well as access to basic services, ownership 
  and control over land and other forms of property, inheritance, natural resources, 
  appropriate new technology and financial services, including microfinance", 
  "Implement nationally appropriate social protection systems and measures for all, 
  including floors, and by 2030 achieve substantial coverage of the poor and the vulnerable", 
  "Significantly reduce all forms of violence and related death rates everywhere")), 
  class = c("tbl_df", "tbl", "data.frame"), row.names = c(NA, 
  -13L))

  # ctry <- ForcedDisplacementStat::reference |>
  #          filter(iso_3 == country ) |> 
  #          select(iso_3, ctryname, M49_code) 
  
  sdg_code_label <- sdg_rbm |>
           filter(RMS == rbm  )
  
  sdg_code <- sdg_rbm |>
           filter(RMS == rbm  ) |>
           pull(indicator)
  
  #cat(paste0("\n \n -------\n Pulling RMS Host country comparison data for ", ctry$ctryname,  "\n\n"))
  #cat(paste0("Retrieving now : ", sdg_code_label$SDG_indic , "\n"))
  Ind1 <- SDGsR::get_indicator(Country = countrycode::countrycode(country, 
                                                                  origin = 'iso3c', 
                                                                  destination = 'un'), 
                               indicator= sdg_code)

  ## Check if the API did return something
  if(nrow(Ind1) == 0) {
        #cat(paste0("\n \u0ca0_\u0ca0  \n No data rcould be etrieved  from API for ", sdg_code_label$SDG_indic , " in country: ", ctry$ctryname ,"n\n"))
        p <-  ggplot() +     
             annotate("text",  x = 1, y = 1,  size = 10,
             label = stringr::str_wrap(paste0("\n \u0ca0_\u0ca0  \n No data could be retrieved from  UNStat API for: ", 
                          sdg_code_label$SDG_indic , " (related to UNHCR Indicator ", rbm ,
                          ") in country: ", 
                          countrycode::countrycode(country,  
                                                   origin = 'iso3c',
                                                   destination = 'country.name') ,
                          "."), 50 ) ) +   theme_void()
    
    
       return(p)
    } else {
       # cat(paste0("Done! ", nrow(Ind1), " records gathered   \u30fd(\u00b4\u25bd`)/ \n\n"))
  
  ## Remove rows when value is NaN
  Ind1 <- Ind1[ !(is.nan(Ind1$value)), ]
  ## Replace NaN by NA for upper and lower Bound
  Ind1$upperBound <- ifelse(is.nan(Ind1$upperBound), NA , Ind1$upperBound )
  Ind1$lowerBound <- ifelse(is.nan(Ind1$lowerBound), NA , Ind1$lowerBound )

  #cat ("sleep 3 sec between each indicators...")
  #Sys.sleep(3)


  #Ind1$target <- as.character(Ind1$target )
 Ind1  <- Ind1 %>% 
           as.data.frame()  %>%
           janitor::clean_names() %>%  
           ## Cleaning a few country name for better legibility
            dplyr::mutate ( geo_area_name = stringr::str_replace(geo_area_name, "Venezuela \\(Bolivarian Republic of\\)", "Venezuela"),
                      geo_area_name = stringr::str_replace(geo_area_name, "Bolivia \\(Plurinational State of\\)", "Bolivia")) #%>%  
           #dplyr::left_join(Goals, by="target")
   #names(Ind1)

   ## remove all empty disaggregation
   # Ind2 <- as.data.frame(Ind1[ , colSums(is.na(Ind1)) == 0])
   Ind2 <- Ind1%>%  
                   select(series_description, geo_area_name, time_period_start,value ) %>% 
                  group_by(series_description, geo_area_name, time_period_start) %>% 
      ## Aggregate base on Unit type - aka sum or average 
        summarize(valmean = mean(as.numeric(value)),
                  valsum = sum(as.numeric(value))  )%>% 
           #So we overprint in the right order
            arrange(time_period_start) #%>% 
      
    if( unique(Ind1$attributes$Units) %in% c("NUM_TH" , "NUMBER") ) {
        Ind2$value <- Ind2$valsum
      } else {
        Ind2$value <- Ind2$valmean
      }
    # names(Ind2)
   p <- ggplot(data =  Ind2, 
             aes(x = time_period_start,
                 y = value,
                 group = 1)) +
        geom_line( linewidth = 1.5, color = "#0072BC" ) +
        geom_point(shape =15, size = 2, color = "#0072BC") +  
        facet_wrap(~ series_description) +
       #scale_y_continuous(labels = unhcRstyle::format_si()) +
        scale_x_continuous(limits = years) +
        #geom_hline(yintercept = 0, size = 0.7, colour = "#333333") +
        unhcrthemes::theme_unhcr(font_size = 20) + ## Insert UNHCR Style
        theme(panel.grid.major.y  = element_line(color = "#cbcbcb"), 
              panel.grid.major.x  = element_blank(), 
              panel.grid.minor = element_blank(),
              #panel.grid.major.x = element_blank(),
              legend.position="none",
              strip.text.x = element_text(size = 8)) +
        labs(title = stringr::str_wrap(paste0(  countrycode::countrycode(country,  
                                                   origin = 'iso3c',
                                                   destination = 'country.name'), ": ",sdg_code_label$description ), 80), 
             subtitle = stringr::str_wrap( paste0(sdg_code_label$SDG_indic, " (related to UNHCR Indicator ", rbm, ")"), 100),
             x = " ", 
             y = paste0(unique(Ind1$attributes$Units)),
             caption = stringr::str_wrap( paste0("Source: ", unique(Ind1$source), ", Data extracted from UNStat API"), 100))
   
        #  gghighlight::gghighlight(value >= mean(dfna1$value),
        # #value - sdval,
        #                  use_direct_label = FALSE) + 
        # geom_tile( data = yearfocus,
        #            aes(x = year, 
        #                y = value, 
        #                fill = as_factor((decade/10)%%2)),
        #            show.legend = FALSE) +
        # scale_fill_manual(values = c("0" = "white", 
        #                              "1" = "#99999922")) +  
   return(p)
   
  }
   
}
```
  
```{r example-fct_plot_rbm_sdg}
fct_plot_rbm_sdg( country = "BRA",
          rbm = "impact2_2",
          years = c(2000, 2022)) +
        unhcrthemes::theme_unhcr(font_size = 10)
```
  
```{r tests-fct_plot_rbm_sdg}
test_that("fct_plot_rbm_sdg works", {
  expect_true(inherits(fct_plot_rbm_sdg, "function")) 
})
```
  
# Export Indicator table 

## fct_compass_table
    
```{r function-fct_compass_table}
#' @title Write simple compass indicator table
#' @description The function take the list of calculated variables from an RMS
#'              and output an excel document in the same folder with the correct
#'              format for import into COMPASS.
#'
#'              The function assumes you have already calculated the indicators and
#'              have a datalist object with all the correct calculation inside.
#'              
#'              The output can conveniently be upoaded as an indicator ressource in ridl
#'
#' @param country iso3 code for the country (easier to recall than the M49 used in the API)
#' @param operation operation name
#' @param year year to use to extract the baseline from Population Statistics
#' @param population_type  The list of population type for baseline calculation
#' @param population_rms  The list of population type covered by RMS
#' @param rms_indicator list with indicators and their related frame to pull the value
#' @param ridl name of ridl data container to push the data to
#' @param publish yes / no 
#'
#' @import  refugees  
#' @importFrom janitor clean_names
#'
#' @return frame with all compass indicators
#' 
#' @export
#'
fct_compass_table <- function(country ,
                                operation,
                                year ,
                                population_type,
                                population_rms,
                                rms_indicator,
                                ridl,
                                publish) {
# 
# 
#   totalBaseline <- refugees::population  |>
#     filter(CountryAsylumCode == country,
#            Year == 2022 ,
#            Population.type %in% population_type)  |>
#     group_by(CountryAsylumName)  |>
#     summarise(Value = sum(Value, na.rm = TRUE)) |>
#     ungroup() |>
#     dplyr::pull( Value)
# 
#   rms_indicator =  as.data.frame(rms_indicator)
# 
#   ## Initialise the data frame
#   compass <- data.frame( t(c( a =  operation,
#        b = population_rms,
#        c =  "Percent",
#        d =  totalBaseline,
#        e = 10,
#        f =  10,
#        g = "XXX" )) )
# 
#   ## append all the values
#   for (i in (1:nrow(rms_indicator))) {
#     # i <- 3
#     t <- as.data.frame(eval(parse(text= paste0("table( datalist[[\"",
#                                  rms_indicator[i,1] ,
#                                  "\"]]$",
#                                  rms_indicator[i, 2] ,")" ) )))
#     #cat( paste0(rms_indicator[i,3] , "\n"))
# 
#     #class(t)
#     if( nrow(t) == 0) {
#       t1 <- 0 } else  if( nrow(t |> dplyr::filter(Var1 ==1 ))  == 1)  {
#       t1 <- eval(parse(text= paste0("as.data.frame( prop.table(table( datalist[[\"",
#                             rms_indicator[i,1],"\"]]$",
#                             rms_indicator[i,2],"))) |>
#                             dplyr::filter(Var1 ==1 ) |> dplyr::pull(Freq)"))) } else {
#       t1 <- 0}
#     compass1 <- as.data.frame(t(c( a = operation,
#          b =  population_rms,
#          c = "Percent",
#          d =  totalBaseline,
#          e = round(t1 * 100,2),
#          f = round(totalBaseline *t1),
#          g = rms_indicator[i,3] )))
#     #str(compass)
#     #str(compass1)
#     compass <- rbind( compass,compass1)
#     rm(compass1)
#     }
# 
#   compass <- compass |>
#     as.data.frame() |>
#     dplyr::slice(-1) |>
#     dplyr::mutate (Plan = a ,
#                    `Population Type (operational)` = b ,
#                    `Show As` = c,
#                    `Baseline Num.` =  f,
#                    `Baseline Den.` = d,
#                    `%`  = e ,
#                    `Indicator` = g)|>
#     dplyr::select(Plan,
#                   `Indicator`,
#                   `Population Type (operational)`,
#                   `Show As`,
#                   `Baseline Num.`,
#                   `Baseline Den.`,
#                   `%`  )
# 
#   ## And now saving
#   ## Create a new workbook
#   wb <- openxlsx::createWorkbook()
#   ## add the cleaning log to the file
#   openxlsx::addWorksheet(wb, "Compass")
#   openxlsx::writeData(wb,  "Compass",
#                       compass, withFilter = TRUE)
#   ## Save workbook
#   openxlsx::saveWorkbook(wb,
#                          file = here::here(paste0("compass_",
#                                                  country,"_",
#                                                  stringr::str_replace_all(string=population_rms, pattern=" ", repl=""),
#                                                  ".xlsx") ),
#                          overwrite = TRUE)
#   
#   
#   ## Now push to RILD 
#   if( publish == "yes"){
#   p <- riddle::dataset_show(param$ridl)
#   list_of_resources <- p[["resources"]][[1]]
# 
#   time <- format(Sys.Date(),  '%d%b%y')
#   ### Publish the analysis plan ####
#   namecompass = paste0("compass_",  country,"_",
#                        stringr::str_replace_all(string=population_rms, pattern=" ", repl=""))
#   ### Check if the name is already in the resources
#   if(namecompass %in% list_of_resources$name) {
#         ## get the resource id
#         resourceid <- list_of_resources |>
#                       dplyr::filter ( name == namecompass) |>
#                        dplyr::pull(id)
#         ## get the new resource version
#         curversion <- list_of_resources |>
#           dplyr::filter ( name == namecompass) |>
#           dplyr::pull(version)
# 
#         ## Build resource metadata
#         metadatacompass <- riddle::resource_metadata(
#             type = "attachment",
#             url = paste0(namecompass, ".xlsx"),
#             name = namecompass,
#             description = paste0("Compass output generated from RMS on ",  time,
#                                  ". Built using kobocruncher "),
#             format = "xlsx",
#             version = (curversion + 1),
#             visibility =  "public",
#             file_type = "other",
#             ## Revise here based on the name from your crunching report
#             upload =  httr::upload_file(here::here(paste0(namecompass, ".xlsx")))
#           )
#         riddle::resource_update(id = resourceid,
#                                 res_metadata = metadatacompass)
#     } else {
# 
#         metadatacompass <- riddle::resource_metadata(
#           type = "attachment",
#           url = paste0(namecompass, ".xlsx"),
#           name = namecompass,
#             description = paste0("Compass output generated from RMS on ",  time,
#                                  ". Built using kobocruncher "),
#           format = "xlsx",
#           visibility =  "public",
#           file_type = "other",
#           ## Revise here based on the name from your crunching report
#           upload =  httr::upload_file(here::here(paste0(namecompass, ".xlsx")))
#         )
#         riddle::resource_create(package_id = p$id,
#                                 res_metadata = metadatacompass)
#     }
#   
#    }
# 
#   return(compass)

}
```
  
```{r example-fct_compass_table}
# compass <- export_compass_fill( country = "ECU",
#                        operation = "Ecuador ABC",
#                        year = 2022,
#                         population_type = c("REF","ASY", "OIP"),
#                         population_rms = "Refugees and Asylum-seekers",
#                         rms_indicator =    rbind(
#   c("main", "impact2_2",  "2.2 Proportion of PoCs residing in physically safe and
#                            secure settlements with access to basic facilities"),
#   c("main", "impact2_3",  "2.3 Proportion of PoC with access to health services"),
#   c("P2.S3", "impact3_2a", "3.2a Proportion of PoC enrolled in primary education" ),
#   c("P2.S3", "impact3_2b",  "3.2b Proportion of PoC enrolled in secondary education" ),
#   c("main", "impact3_3",  "3.3 Proportion of PoC feeling safe walking alone in their neighborhood (related SDG 16.1.4)." ),
#   c("S2", "outcome1_2", "1.2 Proportion of children under 5 years of age whose births
#                    have been registered with a civil authority. [SDG 16.9.1 - Tier 1]" ),
#   c("S2", "outcome1_3", "1.3 Proportion of PoC with legally recognized identity documents or credentials [GCR 4.2.2]." ),
#   c("main", "outcome4_1", "4.1 Proportion of PoC who know where to access available GBV services." ),
#   c("main", "outcome4_2", "4.2 Proportion of POCs who do not accept violence against women." ),
#   c("main", "outcome8_2", "8.2 Proportion of PoC with primary reliance on clean (cooking) fuels and technology [SDG 7.1.2 Tier 1]" ),
#   c("main", "outcome9_1", "9.1 Proportion of PoCs living in habitable and affordable housing." ),
#   c("main", "outcome9_2", "9.2 Proportion of PoC that have energy to ensure lighting (close to Sphere)." ),
#   c("main","outcome12_1", "12.1 Proportion of PoC using at least basic drinking water services (SDG)." ),
# #  c("main" , "outcome12_2", "12.2 Proportion of PoC with access to a safe household toilet (SDG)." ),
#   c("main", "outcome13_1", "13.1. Proportion of PoC with an account at a bank or other
#                               financial institution or with a mobile-money-service provider [SDG 8.10.2 Tier 1]." ),
#   c("main", "outcome13_2", "13.2. Proportion of PoC who self-report positive changes in their income compared to previous year." ),
#   c("main", "outcome13_3",  "13.3 Proportion of PoC (working age) who are unemployed." ),
#   c("main", "outcome16_1", "16.1. Proportion of PoC with secure tenure rights and/or
#     property rights to housing and/or land [revised SDG indicator 1.4.2]." )#,
#  # c("main", "outcome16_2", "16.2. Proportion of PoC covered by social protection floors/systems [SDG 1.3.1]." )
#      ),
#              ridl = params$ridl,
#              publish = params$publish )
```
  
```{r tests-fct_compass_table}
#test_that("fct_compass_table works", {  expect_true(inherits(fct_compass_table, "function")) })
```
  
 



# Utilities

## fct_build_requirement
    
```{r function-fct_build_requirement}
#' fct_build_requirement
#' 
#' Write in a file the variable requirement for each single indicator functions
#' 
#' The function is used to conveniently keep the mapping between the excel 
#' tables used to show variable requirements for each indicator calculation 
#' 
#' It expects a specific table within the xlsform called `Indicator_to_question`

#' @param xlsformpath path to the xlsform
#' @return print in console
#' 
#' @export
fct_build_requirement <- function(xlsformpath){
   
   mappers <- readxl::read_excel(xlsformpath,
                      sheet = "Indicator_to_question") |>
     dplyr::select(IndName, MeasureLevel, QuestionVar)

   dico <- kobocruncher::kobo_dico(  xlsformpath  )

    # View(dico[["variables"]])
    # names(dico[["variables"]])

    mappers <- mappers |>
            dplyr::left_join( dico[["variables"]] |> 
                                dplyr::select(name, label,
                                             type, list_name, name_or),
                                by= c("QuestionVar" = "name_or"))


   IndicMap <- mappers |>
        dplyr::left_join( dico[["modalities"]] |>
                      dplyr::select(name, label, list_name ) |>
                      dplyr::rename( name_mod = name,
                                     label_mod = label),
                    by= c("list_name"))  

   #writexl::write_xlsx(IndicMap, here::here( "inst", "IndicMap.xlsx"))
   # IndicMap <- readxl::read_excel( system.file("IndicMap.xlsx",
   #                                             package = "IndicatorCalc"))
  
  ## Below is the format we are trying to replicate
  
  # mapper = list(
  #           hierarchy = "main",
  #           variablemap = data.frame(
  #             label = c("Does this household use anything for lighting?",
  #                       "What source of electricity is used most of the time in this household?"),
  #             variable = c("LIGHT01", 
  #                          "LIGHT03"),
  #             mappattern = c("LIGHT01", 
  #                          "LIGHT03") ),
  #           modalitymap = data.frame(
  #             variable = c( "LIGHT01", 
  #                           "LIGHT03", "LIGHT03", "LIGHT03"),
  #             label = c( "yes",
  #               "No electricity in household", "Other, specify", "Don\'t know"),
  #             standard = c( "1",
  #                          "1", "96", "98"),
  #             map = c("yes",
  #                     "Noelec", "Other", "Dontknow")
  #           )
  #         )
  
  filemap <- tempfile()
  filemaplab <- tempfile()
  listind <- IndicMap |> dplyr::select(IndName) |> dplyr::distinct() |> dplyr::pull()
   if (file.exists(filemap)) file.remove(filemap) 
  ## Roving around indicators
  for ( thisInd in listind ) {
    # thisInd <- listind[1]
     cat( paste0("# --- ", thisInd, "\n"), file = filemap , sep = "\n", append = TRUE)
     cat( paste0( "# -----------------------------\n"), file = filemap , sep = "\n", append = TRUE)
     cat( paste0( "mapper = list("), file = filemap , sep = "\n", append = TRUE)
     cat( paste0( "           hierarchy = \"",
                  IndicMap |> 
                    dplyr::filter(IndName == thisInd) |> 
                    dplyr::select(MeasureLevel) |> 
                    dplyr::distinct() |> 
                    dplyr::pull(),
               "\","), file = filemap , sep = "\n", append = TRUE)
     ## Mapping variables
     thisvar <- IndicMap |> 
                    dplyr::filter(IndName == thisInd) |> 
                    dplyr::select(QuestionVar, label) |> 
                    dplyr::distinct()  
     cat( paste0( "          variablemap = data.frame("), file = filemap , sep = "\n", append = TRUE)
     cat( paste0( "            label = "), file = filemap , sep = "\n", append = TRUE)
     ## Looping around labels
          dput( thisvar |> dplyr::pull(label) , file = filemaplab )
          file_str <- paste(readLines(filemaplab), collapse="\n")
     cat( paste0(file_str), file = filemap , sep = "\n", append = TRUE)
     cat( paste0( "              ,"), file = filemap , sep = "\n", append = TRUE)
     cat( paste0( "            variable =  "), file = filemap , sep = "\n", append = TRUE)
     ## Looping around  variable
      dput( thisvar |> dplyr::pull(QuestionVar), file = filemaplab )
          file_str <- paste(readLines(filemaplab), collapse="\n")
     cat( paste0(file_str), file = filemap , sep = "\n", append = TRUE)
     cat( paste0( "              ),"), file = filemap , sep = "\n", append = TRUE)
     ## Mapping modality
     thismod <- IndicMap |> 
                    dplyr::filter(IndName == thisInd) |> 
                    dplyr::select(QuestionVar, label_mod, name_mod) |> 
                    dplyr::filter(! (is.null(name_mod)) ) |> 
                    dplyr::distinct()  
     cat( paste0( "          modalitymap = data.frame("), file = filemap , sep = "\n", append = TRUE)
     cat( paste0( "            variable =  "), file = filemap , sep = "\n", append = TRUE)
     ## Looping around variable for modalities
      dput( thismod |> dplyr::pull(QuestionVar) , file = filemaplab )
          file_str <- paste(readLines(filemaplab), collapse="\n")
     cat( paste0(file_str), file = filemap , sep = "\n", append = TRUE)
     cat( paste0( "               ,"), file = filemap , sep = "\n", append = TRUE)
     cat( paste0( "            label =  "), file = filemap , sep = "\n", append = TRUE)
     ## Looping around labels for modalities
      dput( thismod |> dplyr::pull(label_mod) , file = filemaplab )
          file_str <- paste(readLines(filemaplab), collapse="\n")
     cat( paste0(file_str), file = filemap , sep = "\n", append = TRUE)
     cat( paste0( "               ,"), file = filemap , sep = "\n", append = TRUE)
     cat( paste0( "            standard =  "), file = filemap , sep = "\n", append = TRUE)
     ## Looping around standard for modalities
      dput( thismod |> dplyr::pull(name_mod) , file = filemaplab )
          file_str <- paste(readLines(filemaplab), collapse="\n")
     cat( paste0(file_str), file = filemap , sep = "\n", append = TRUE)
     cat( paste0( "              ))"), file = filemap , sep = "\n", append = TRUE) 
     cat( paste0( "# -----------------------------\n"), file = filemap , sep = "\n", append = TRUE)
     
  }
    cat(filemap)
    return(IndicMap)
    
}
```
  
```{r example-fct_build_requirement}
## Write in dev/mapper.R each of the function parameters - as recorded in  system.file("IndicMap.xlsx", package = "IndicatorCalc")
xlsformpath <- system.file("RMS_CAPI_v2.xlsx", package = "IndicatorCalc")
RMS_CAPI_v2_mapper <- fct_build_requirement(xlsformpath )
# openxlsx::write.xlsx(RMS_CAPI_v2_mapper, here::here("inst", "RMS_CAPI_v2_mapper.xlsx"))

xlsformpath <- system.file("RMS_CAPI_v3.xlsx", package = "IndicatorCalc")
RMS_CAPI_v3_mapper <- fct_build_requirement(xlsformpath )
# openxlsx::write.xlsx(RMS_CAPI_v3_mapper, here::here("inst", "RMS_CAPI_v3_mapper.xlsx"))

## CATI
xlsformpath <- system.file("RMS_CATI_v0.xlsx", package = "IndicatorCalc")
RMS_CATI_v0_mapper <- fct_build_requirement(xlsformpath )
# openxlsx::write.xlsx(RMS_CATI_v0_mapper, here::here("inst", "RMS_CATI_v0_mapper.xlsx"))

xlsformpath <- system.file("RMS_CATI_v3.xlsx", package = "IndicatorCalc")
RMS_CATI_v3_mapper <- fct_build_requirement(xlsformpath )
# openxlsx::write.xlsx(RMS_CATI_v3_mapper, here::here("inst", "RMS_CATI_v3_mapper.xlsx"))

```
  
```{r tests-fct_build_requirement}
test_that("fct_build_requirement works", {
  expect_true(inherits(fct_build_requirement, "function")) 
})
```
  
 
 

```{r development-inflate, eval=FALSE}
# Keep eval=FALSE to avoid infinite loop in case you hit the knit button
# Execute in the console directly
fusen::inflate(flat_file = "dev/utilities.Rmd", vignette_name = "Utilities")
```

 
