---
title: "Get Started"
output: html_document
editor_options: 
  chunk_output_type: console
---

<!-- Run this 'development' chunk -->
<!-- Store every call to library() that you need to explore your functions -->

```{r development, include=FALSE}
library(testthat)
```

<!--
 You need to run the 'description' chunk in the '0-dev_history.Rmd' file before continuing your code there.

If it is the first time you use {fusen}, after 'description', you can directly run the last chunk of the present file with inflate() inside.
--> 



```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```



```{r development-dataset}
# Run all this chunk in the console directly
# There already is a dataset in the "inst/" directory
# Make the dataset file available to the current Rmd during development
pkgload::load_all(path = here::here(), export_all = FALSE)

 
```


# Generating data from a specific form definition

One key function is to generate a dummy dataset based on a specific form structure

To demonstrate the package we will use the standard questionnaire and then apply 
 each indicator function to demonstrate them.
 
We can then also re-use the function to create dummy data based on any form and then apply 
 each indicator function to actually verify which indicators can be created based
 on the form content.

## var_dummy
    
```{r function-var_dummy}
#' var_dummy 
#' 
#'  Append to an existing dataframe new Generate the variable based on 1. type, 2. constraint and 3.relevance
#'  
#' @param frame dataframe object where new dummy varaible will be created...
#' @param name name of the variable to be created
#' @param type type of the variable to be created in line with xlsform  -
#'             one of the following 6 options:  
#'        "select_one", "select_multiple", "text", "integer", "numeric", "date"
#'        
#'         "start ", "end", "calculate",  "geopoint","acknowledge",
#'         "begin_group", "end_group", "begin_repeat", "end_repeat" , "note"  
#'             
#' @param list_opt  a vector with all possible values for select_one and select_multiple
#'                   - can be null
#' @param constraint  specific constraint - used for for numeric or integer
## @param seed random seed
#' 
#' @return  dataframe
#' 
#' @importFrom withr with_seed
#' @importFrom dplyr mutate n tibble rename
#' @importFrom stats rlnorm
#' @importFrom tidyr unnest
#' 
#' @noRd
#' 
#' @export
var_dummy <- function( frame,
                       name, 
                       type,
                       list_opt, 
                       constraint #,
                     #  seed = 1976
                     )  {
   ## number of records to be generated depends on the initial frame..
   n <- nrow(frame)
   #withr::with_seed(seed = seed)
  # withr::with_seed(
   # seed = seed,
   # suppressWarnings(

       # no content ###########
      if( type %in% c("begin_group", "end_group", "begin_repeat", "end_repeat" , "note" )) {
        res <- dplyr::tibble(
             thisvar = NA)
        names(res)[1] <- name
        frame <- cbind(frame,res)
      }
   
   
       ## acknowledge ###########
      if( type %in% c("acknowledge")) {
        res <- dplyr::tibble(
             thisvar = sample(c(0,1), n, replace = TRUE))
        names(res)[1] <- name
        frame <- cbind(frame,res)
      }
   
   
      ## select one ###########
      if( type %in% c("select_one") ) {
      res <- dplyr::tibble( thisvar = sample(c(list_opt), n, replace = TRUE) ) 
      ## Now rename the variable
      names(res)[1] <- name
      frame <- cbind(frame,res)
      }
      
      ## select multiple ###########
      if( type %in% c("select_multiple")) {
            for (modality in list_opt) {
                res <- dplyr::tibble(
                 thisvar = sample(c(0,1), n, replace = TRUE)) 
                names(res)[1] <- paste0(name, "_",modality )
                frame <- cbind(frame,res)
            }
      }

      ## stext ###########
      if( type %in% c("text")) {
      res <- dplyr::tibble(
        thisvar = paste0( "FreeText_",
                      purrr::as_vector(
                            purrr::map(n, sample(LETTERS, 6)) |>
                            purrr::map(paste0, collapse = "")),
                          "-",
                          formatC(1:n, width = nchar(n) + 1, flag = "0")
                        ))
      ## Now rename the variable
      names(res)[1] <- name
      frame <- cbind(frame,res)
      }
      
     ## numeric ###########    
     if( type %in% c("numeric", "integer", "calculate", "geopoint")) {
      ## TODO extract elements from constraint to define num1 an num2
      num1 <-  18
      num2 <-  95
      
      res <- dplyr::tibble(
        thisvar = sample(num1:num2, n, replace = TRUE))
      ## Now rename the variable
      names(res)[1] <- name
      frame <- cbind(frame,res)
     }

     ## date ###########   
     if( type %in% c("date",  "start ", "end")) {
      res <- dplyr::tibble(
        thisvar  = Sys.time() - abs(rnorm(n, 0, sd = 2) * 365 * 24 * 3600))
      ## Now rename the variable
      names(res)[1] <- name
      frame <- cbind(frame,res)
     }

   # )
  # )

  return(frame)  
}
```
  
```{r example-var_dummy}

## let's initiate a dataframe with an index of n r records
n <- 384
frame <- dplyr::tibble(
        index = paste0( "ID-",
                      purrr::as_vector(
                            purrr::map(n, sample(LETTERS, 4)) |>
                            purrr::map(paste0, collapse = "")),
                          "-",
                          formatC(1:n, width = nchar(n) + 1, flag = "0")
                        ))

## test inject select_one  
frame <- var_dummy( 
          frame = frame,
           name = "testselect_one",
           type = "select_one",
           list_opt = c("alpha", "beta", "delta"),
           constraint = NULL
           )
## test inject select_multiple in main
frame <- var_dummy( 
          frame = frame,
          name = "testselect_multiple",
           type = "select_multiple",
           list_opt = c("alpha", "beta", "delta"),
           constraint = NULL
           )

## test inject text
frame <- var_dummy( 
          frame = frame,
          name = "testtext",
           type = "text",
           list_opt = NULL,
           constraint = NULL
           )


## test inject numeric  
frame <- var_dummy(
           frame = frame,
           name = "testnumeric",
           type = "numeric",
           list_opt = NULL,
           constraint = NULL
           )

## test inject date  
frame <- var_dummy( 
          frame = frame,
          name = "testdate",
           type = "date",
           list_opt = NULL,
           constraint = NULL
           )

## Preview out out
knitr::kable(head(frame, 5))
```
  
```{r tests-var_dummy}
test_that("var_dummy works", {
  expect_true(inherits(var_dummy, "function")) 
})
```
   
 
## kobo_dummy
 
    
```{r function-kobo_dummy}
#' kobo_dummy
#' 
#' @description Automatically produce an dummy dataset in line with the structure 
#' of an XlsForm
#'  Making decisions about research design and analysis strategies is often difficult before data is collected,
#' because it is hard to imagine the exact form data will take.
#' This function helps imagine what data will look like before they collect it.
#' samplesize is set per defautl at 500 records
#'
#'  Supported Features: 
#' - Generate a data set  
#' - respects ODK structure "`relevant`" skip logic
#'    (Some advanced functionality such as "coalesce()" not covered)
#' - respects "`constraint`" 
#' - respects "`repeat`" adds ID column to link hierarchical data based on "`repeat_count`"
#'  This function is a rewriting of
#'     https://unhcr.github.io/koboloadeR/docs/reference/kobo_dummy.html 
#'   it also  build on  https://thinkr-open.github.io/fakir/ and
#'     https://docs.ropensci.org/charlatan/
#' 
#' @param  form file path of the XlsForm
#' @param n number of main records to be generated
#' @param nrepeat max random number of repeat records to be generated 
#'           when repeat_count is not mentionned 
#' @param file file as xlsx where to save to the  
#' 
#' @importFrom kobocruncher kobo_dico
#' 
#' 
#' @return a data list with a series of dummy data 
#' 
#' @export
kobo_dummy <- function(form,
                       n = 384,
                       file){
  
  dico <- kobocruncher::kobo_dico(xlsformpath = form)

  ## Get the variables to extract
  frame <- "main"
  
  conf <- data.frame(
      name <- dico[["variables"]] |>
        dplyr::filter(repeatvar ==  frame)  |> 
        dplyr::select(name),
      
      # dico[["variables"]]|>
      #   dplyr::filter(repeatvar ==  frame)  |> 
      #   dplyr::distinct(type)
      type <- dico[["variables"]]|>
        dplyr::filter(repeatvar ==  frame)  |> 
        dplyr::select(type),
      
      ## pulling list options...
      list_opt <- dico[["variables"]] |>
        dplyr::filter(repeatvar ==  frame)  |> 
        dplyr::select(list_name) ,
        #dplyr::left_join(modal, by = c("list_name")) |>
      #  dplyr::select( list_opt)
      
      
      constraint <- dico[["variables"]]|>
        dplyr::filter(repeatvar ==  frame)  |> 
        dplyr::select(constraint)
  )
  
  ## We start with the generation of the main frame
  ## Build the main table and initiate it an index.....
  main <- dplyr::tibble(
        index = paste0( "ID-",
                      purrr::as_vector(
                            purrr::map(n, sample(LETTERS, 4)) |>
                            purrr::map(paste0, collapse = "")),
                          "-",
                          formatC(1:n, width = nchar(n) + 1, flag = "0")
                        ))
  names(main)[1] <- "_index"
  
  ## then apply var_dummy interactively... 
  for(i in (1:nrow(conf)) ) {
   # i <- 6
    cat(paste0(i, "-", conf[i, c("type")], "-", conf[i, c("name")],  "\n"))
  
  ## manage specific case when list name is not defined in ccoices but pulled from data..
  ## in such case we replace type by select_one by text
  this.type <-  conf[i, c("type")]
  this.name <-  conf[i, c("name")]
  this.listname <- conf[i , c("list_name")]
  this.constraint =  conf[i, c("constraint")] 
  
  if( !(this.listname %in% c( dico[["modalities"]] |>  dplyr::pull(list_name))) ) { 
     this.listname <- NULL
     this.type <- "text"
     }
   
   main <- var_dummy( 
          frame = main,
          name = this.name,
          type = this.type,
          list_opt =  c(dico[["modalities"]] |>
                         dplyr::filter(list_name == this.listname   )  |>
                         dplyr::pull(name) ),
          constraint =  this.constraint )
  }
    
  ## Still struggling with purrr
  # test  <- purrr::map(  main,
  #                       name,
  #                       type,
  #                       list_opt$list_opt ,
  #                       constraint ,
  #                     var_dummy)
  
  ## TODO -- apply the relevance statement...
  ## define when the variable should exist based on other elements
  ## Need to convert the xlsform statement into R syntax
  # relevant <- dico[["variables"]]|>
  #   dplyr::filter(repeatvar == "main")  |> 
  #   dplyr::pull(relevant)
  
  ## replace  \" by ' 
  ## replace '=' by '=="
  ## replace '!==' by '!=" (to fix previsous replace)
  ## replace '${' '}'  with nothing..
  ## replace 'or'  with  '|'..
  ## replace 'and'  with '&'..
  
  ## Now store in the list...
  datalist <- list ( "main" = main) 

  ## treat cases with repeat table.. #####
  repeatvar <- dico[["variables"]] |> 
    dplyr::select(repeatvar)  |>
    dplyr::filter(repeatvar != "main")  |>
    dplyr::distinct()   |>
    dplyr::pull()   
  ## need to separate the different repeat elements wthin the form...
  for ( rep in repeatvar ) {
        
               confrep <- data.frame(
                    name <- dico[["variables"]] |>
                      dplyr::filter(repeatvar ==  rep)  |> 
                      dplyr::select(name),
                    
                    # dico[["variables"]]|>
                    #   dplyr::filter(repeatvar ==  rep)  |> 
                    #   dplyr::distinct(type)
                    type <- dico[["variables"]]|>
                      dplyr::filter(repeatvar ==  rep)  |> 
                      dplyr::select(type),
                    
                    ## pulling list options...
                    list_opt <- dico[["variables"]] |>
                      dplyr::filter(repeatvar ==  rep)  |> 
                      dplyr::select(list_name) ,
                      #dplyr::left_join(modal, by = c("list_name")) |>
                    #  dplyr::select( list_opt)
                    
                    
                    constraint <- dico[["variables"]]|>
                      dplyr::filter(repeatvar ==  rep)  |> 
                      dplyr::select(constraint)
                  )
            
            ## We start with the generation of the main frame
            ## Build the main table and initiate it an index.....
            repframe <- dplyr::tibble(
                  index = paste0( "ID-",
                                purrr::as_vector(
                                      purrr::map(n, sample(LETTERS, 4)) |>
                                      purrr::map(paste0, collapse = "")),
                                    "-",
                                    formatC(1:n, width = nchar(n) + 1, flag = "0")
                                  ))
            
            names(repframe)[1] <- "_parent_index"
            ## Apply now `_index`
            ## TODO -- check if we have a `repeat_count` to apply limitation..
            
            ## then apply var_dummy interactively... 
            for(i in (1:nrow(confrep)) ) {
             # i <- 6
              cat(paste0(i, " in repeat -", rep, " ///", confrep[i, c("type")], "-", confrep[i, c("name")],  "\n"))
            
            ## manage specific case when list name is not defined in ccoices but pulled from data..
            ## in such case we replace type by select_one by text
            this.type <-  confrep[i, c("type")]
            this.name <-  confrep[i, c("name")]
            this.listname <- confrep[i , c("list_name")]
            this.constraint =  confrep[i, c("constraint")] 
            
            if( !(this.listname %in% c( dico[["modalities"]] |>  dplyr::pull(list_name))) ) { 
               this.listname <- NULL
               this.type <- "text"
               }
             
             repframe <- var_dummy( 
                    frame = repframe,
                    name = this.name,
                    type = this.type,
                    list_opt =  c(dico[["modalities"]] |>
                                   dplyr::filter(list_name == this.listname   )  |>
                                   dplyr::pull(name) ),
                    constraint =  this.constraint )
            }
        
        
        ## append to the repeat
        datalist[[rep]] <- repframe
      }
    
  
  

  return(datalist)
  }
```
  
```{r example-kobo_dummy}
form <- system.file("RMSCAPI.xlsx", package = "IndicatorCalc")
datalist <- kobo_dummy(form,
                       n = 384,
                       file = NULL)

## Save this to use it for testing the package...

openxlsx::write.xlsx(datalist, here::here("inst", "demo_data.xlsx"))
```
  
```{r tests-kobo_dummy}
test_that("kobo_dummy works", {
  expect_true(inherits(kobo_dummy, "function")) 
})
```


## plot_rbm_sdg - SDG Comparison
    
```{r function-plot_rbm_sdg}
#' @title Plot SDG Indicator for a country
#' @description The function is designed to help the interpretation of survey 
#'  results by providing a comparison guidelines. It displays a chart to have a 
#'  base of comparison when analyzing the results of UNHCR of UNHCR Result monitoring
#'  survey. It pulls the values published within the UN Registry of SDG Indicator values
#'  The function includes a mapping table between RBM/RMS and SDG and 
#'  extract the data from https://unstats.un.org/SDGAPI/swagger/ using the package SDGsR
#'  https://drmattg.github.io/SDGsR/articles/Introduction_to_SDGsR.html
#'               devtools::install_github("DrMattG/SDGsR", dependencies = TRUE)
#' @param country iso3 code for the country (easier to recall than the M49 used in the API)
#' @param rbm  the RBM variable name - that can match SDG 
#' @param years  years to filter the chart - for instance c(2000,2022)
#' 
#' @importFrom SDGsR get_indicator
#' @importFrom countrycode countrycode
#' @importFrom janitor clean_names
#' @importFrom stringr str_replace
#' 
#' @return a ggplot2 object
plot_rbm_sdg <- function( country = "BRA", 
                      rbm = "outcome16_2",
                      years = c(2000, 2022)) {
  require(ggplot2)
  require(dplyr)
  
  ## Below is a mapping table between indicators codes for UNHCR and SDG...
sdg_rbm <-  structure(list(
  indicator = c("1.4.1", "3.8.1", "16.9.1", "7.1.2", 
                "7.1.1", "3.1.2", "6.1.1", "6.2.1", 
                "8.10.2", "8.5.2", "1.4.2", "1.3.1", "16.1.4"), 
               
  SDG_indic = c(
    "1.4.1 Proportion of population living in households with access to basic services", 
  "3.8.1 Coverage of essential health services (defined as the average coverage of 
  essential services based on tracer interventions that include reproductive, maternal, 
  newborn and child health, infectious diseases, non-communicable diseases and service 
  capacity and access, among the general and the most disadvantaged population)", 
  "16.9.1 Proportion of children under 5 years of age whose births have been registered 
  with a civil authority, by age", 
  "7.1.2 Proportion of population with primary reliance on clean fuels and technology", 
  "7.1.1 Proportion of population with access to electricity", 
  "3.1.2 Proportion of births attended by skilled health personnel", 
  "6.1.1 Proportion of population using safely managed drinking water services", 
  "6.2.1 Proportion of population using (a) safely managed sanitation services and (b) 
  a hand-washing facility with soap and water", 
  "8.10.2 Proportion of adults (15 years and older) with an account at a bank or other
  financial institution or with a mobile-money-service provider", 
  "8.5.2 Unemployment rate, by sex, age and persons with disabilities", 
  "1.4.2 Proportion of total adult population with secure tenure rights to land, (a)
  with legally recognized documentation, and (b) who perceive their rights to land as 
  secure, by sex and type of tenure", 
  "1.3.1 Proportion of population covered by social protection floors/systems, by sex,
  distinguishing children, unemployed persons, older persons, persons with disabilities,
  pregnant women, newborns, work-injury victims and the poor and the vulnerable", 
  "16.1.4 Proportion of population that feel safe walking alone around the area they live"), 
  
  RMS = c("impact2_2", "impact2_3", "outcome1_2", "outcome8_2", 
          "outcome9_2", "outcome10_2", "outcome12_1", "outcome12_2", "outcome13_1", 
          "outcome13_3", "outcome16_1", "outcome16_2", "impact3_3"),
  
  target = c("1.4", 
  "3.8", "16.9", "7.1", "7.1", "3.1", "6.1", "6.2", "8.10", "8.5", 
  "1.4", "1.3", "16.1"),
  
  description = c("By 2030, ensure that all men and women, in particular the poor and 
                  the vulnerable, have equal rights to economic resources, as well as 
                  access to basic services, ownership and control over land and other
                  forms of property, inheritance, natural resources, appropriate new 
                  technology and financial services, including microfinance", 
  "Achieve universal health coverage, including financial risk protection, access to
  quality essential health-care services and access to safe, effective, quality and
  affordable essential medicines and vaccines for all", 
  "By 2030, provide legal identity for all, including birth registration", 
  "By 2030, ensure universal access to affordable, reliable and modern energy services", 
  "By 2030, ensure universal access to affordable, reliable and modern energy services", 
  "By 2030, reduce the global maternal mortality ratio to less than 70 per 100,000 live births", 
  "By 2030, achieve universal and equitable access to safe and affordable drinking water for all", 
  "By 2030, achieve access to adequate and equitable sanitation and hygiene for all and
  end open defecation, paying special attention to the needs of women and girls and those
  in vulnerable situations", "Strengthen the capacity of domestic financial institutions 
  to encourage and expand access to banking, insurance and financial services for all", 
  "By 2030, achieve full and productive employment and decent work for all women and men,
  including for young people and persons with disabilities, and equal pay for work of equal value", 
  "By 2030, ensure that all men and women, in particular the poor and the vulnerable, 
  have equal rights to economic resources, as well as access to basic services, ownership 
  and control over land and other forms of property, inheritance, natural resources, 
  appropriate new technology and financial services, including microfinance", 
  "Implement nationally appropriate social protection systems and measures for all, 
  including floors, and by 2030 achieve substantial coverage of the poor and the vulnerable", 
  "Significantly reduce all forms of violence and related death rates everywhere")), 
  class = c("tbl_df", "tbl", "data.frame"), row.names = c(NA, 
  -13L))

  # ctry <- ForcedDisplacementStat::reference |>
  #          filter(iso_3 == country ) |> 
  #          select(iso_3, ctryname, M49_code) 
  
  sdg_code_label <- sdg_rbm |>
           filter(RMS == rbm  )
  
  sdg_code <- sdg_rbm |>
           filter(RMS == rbm  ) |>
           pull(indicator)
  
  #cat(paste0("\n \n -------\n Pulling RMS Host country comparison data for ", ctry$ctryname,  "\n\n"))
  #cat(paste0("Retrieving now : ", sdg_code_label$SDG_indic , "\n"))
  Ind1 <- SDGsR::get_indicator(Country = countrycode::countrycode(country, 
                                                                  origin = 'iso3c', 
                                                                  destination = 'un'), 
                               indicator= sdg_code)

  ## Check if the API did return something
  if(nrow(Ind1) == 0) {
        #cat(paste0("\n ಠ_ಠ  \n No data rcould be etrieved  from API for ", sdg_code_label$SDG_indic , " in country: ", ctry$ctryname ,"n\n"))
        p <-  ggplot() +     
             annotate("text",  x = 1, y = 1,  size = 10,
             label = stringr::str_wrap(paste0("\n ಠ_ಠ  \n No data could be retrieved from  UNStat API for: ", 
                          sdg_code_label$SDG_indic , " (related to UNHCR Indicator ", rbm ,
                          ") in country: ", 
                          countrycode::countrycode(country,  
                                                   origin = 'iso3c',
                                                   destination = 'country.name') ,
                          "."), 50 ) ) +   theme_void()
    
    
       return(p)
    } else {
       # cat(paste0("Done! ", nrow(Ind1), " records gathered   ヽ(´▽`)/ \n\n"))
  
  ## Remove rows when value is NaN
  Ind1 <- Ind1[ !(is.nan(Ind1$value)), ]
  ## Replace NaN by NA for upper and lower Bound
  Ind1$upperBound <- ifelse(is.nan(Ind1$upperBound), NA , Ind1$upperBound )
  Ind1$lowerBound <- ifelse(is.nan(Ind1$lowerBound), NA , Ind1$lowerBound )

  #cat ("sleep 3 sec between each indicators...")
  #Sys.sleep(3)


  #Ind1$target <- as.character(Ind1$target )
 Ind1  <- Ind1 %>% 
           as.data.frame()  %>%
           janitor::clean_names() %>%  
           ## Cleaning a few country name for better legibility
            dplyr::mutate ( geo_area_name = stringr::str_replace(geo_area_name, "Venezuela \\(Bolivarian Republic of\\)", "Venezuela"),
                      geo_area_name = stringr::str_replace(geo_area_name, "Bolivia \\(Plurinational State of\\)", "Bolivia")) #%>%  
           #dplyr::left_join(Goals, by="target")
   #names(Ind1)

   ## remove all empty disaggregation
   # Ind2 <- as.data.frame(Ind1[ , colSums(is.na(Ind1)) == 0])
   Ind2 <- Ind1%>%  
                   select(series_description, geo_area_name, time_period_start,value ) %>% 
                  group_by(series_description, geo_area_name, time_period_start) %>% 
      ## Aggregate base on Unit type - aka sum or average 
        summarize(valmean = mean(as.numeric(value)),
                  valsum = sum(as.numeric(value))  )%>% 
           #So we overprint in the right order
            arrange(time_period_start) #%>% 
      
    if( unique(Ind1$attributes$Units) %in% c("NUM_TH" , "NUMBER") ) {
        Ind2$value <- Ind2$valsum
      } else {
        Ind2$value <- Ind2$valmean
      }
    # names(Ind2)
   p <- ggplot(data =  Ind2, 
             aes(x = time_period_start,
                 y = value,
                 group = 1)) +
        geom_line( linewidth = 1.5, color = "#0072BC" ) +
        geom_point(shape =15, size = 2, color = "#0072BC") +  
        facet_wrap(~ series_description) +
       #scale_y_continuous(labels = unhcRstyle::format_si()) +
        scale_x_continuous(limits = years) +
        #geom_hline(yintercept = 0, size = 0.7, colour = "#333333") +
        unhcrthemes::theme_unhcr(font_size = 20) + ## Insert UNHCR Style
        theme(panel.grid.major.y  = element_line(color = "#cbcbcb"), 
              panel.grid.major.x  = element_blank(), 
              panel.grid.minor = element_blank(),
              #panel.grid.major.x = element_blank(),
              legend.position="none",
              strip.text.x = element_text(size = 8)) +
        labs(title = stringr::str_wrap(paste0(  countrycode::countrycode(country,  
                                                   origin = 'iso3c',
                                                   destination = 'country.name'), ": ",sdg_code_label$description ), 80), 
             subtitle = stringr::str_wrap( paste0(sdg_code_label$SDG_indic, " (related to UNHCR Indicator ", rbm, ")"), 100),
             x = " ", 
             y = paste0(unique(Ind1$attributes$Units)),
             caption = stringr::str_wrap( paste0("Source: ", unique(Ind1$source), ", Data extracted from UNStat API"), 100))
   
        #  gghighlight::gghighlight(value >= mean(dfna1$value),
        # #value - sdval,
        #                  use_direct_label = FALSE) + 
        # geom_tile( data = yearfocus,
        #            aes(x = year, 
        #                y = value, 
        #                fill = as_factor((decade/10)%%2)),
        #            show.legend = FALSE) +
        # scale_fill_manual(values = c("0" = "white", 
        #                              "1" = "#99999922")) +  
   return(p)
   
  }
   
}
```
  
```{r example-plot_rbm_sdg}
plot_rbm_sdg( country = "BRA", 
          rbm = "impact2_2",
          years = c(2000, 2022)) +
        unhcrthemes::theme_unhcr(font_size = 10) 
```
  
```{r tests-plot_rbm_sdg}
test_that("plot_rbm_sdg works", {
  expect_true(inherits(plot_rbm_sdg, "function")) 
})
```
  
 


## compass_table
    
```{r function-compass_table}
#' @title Write simple compass indicator table
#' @description The function take the list of calculated variables from an RMS
#'              and output an excel document in the same folder with the correct
#'              format for import into COMPASS.
#'
#'              The function assumes you have already calculated the indicators and
#'              have a datalist object with all the correct calculation inside
#'
#' @param country iso3 code for the country (easier to recall than the M49 used in the API)
#' @param operation operation name
#' @param year year to use to extract the baseline from Population Statistics
#' @param population_type  The list of population type for baseline calculation
#' @param population_rms  The list of population type covered by RMS
#' @param rms_indicator list with indicators and their related frame to pull the value
#' @param ridl name of ridl data container to push the data to
#' @param publish yes / no 
#'
#' @importFrom unhcrdatapackage end_year_population_totals_long
#' @importFrom janitor clean_names
#'
#' @return frame with all compass indicators
#' 
#' @export
#'
compass_table <- function(country ,
                                operation,
                                year ,
                                population_type,
                                population_rms,
                                rms_indicator,
                                ridl,
                                publish) {


  totalBaseline <- unhcrdatapackage::end_year_population_totals_long  |>
    filter(CountryAsylumCode == country,
           Year == 2022 ,
           Population.type %in% population_type)  |>
    group_by(CountryAsylumName)  |>
    summarise(Value = sum(Value, na.rm = TRUE)) |>
    ungroup() |>
    dplyr::pull( Value)

  rms_indicator =  as.data.frame(rms_indicator)

  ## Initialise the data frame
  compass <- data.frame( t(c( a =  operation,
       b = population_rms,
       c =  "Percent",
       d =  totalBaseline,
       e = 10,
       f =  10,
       g = "XXX" )) )

  ## append all the values
  for (i in (1:nrow(rms_indicator))) {
    # i <- 3
    t <- as.data.frame(eval(parse(text= paste0("table( datalist[[\"",
                                 rms_indicator[i,1] ,
                                 "\"]]$",
                                 rms_indicator[i, 2] ,")" ) )))
    #cat( paste0(rms_indicator[i,3] , "\n"))

    #class(t)
    if( nrow(t) == 0) {
      t1 <- 0 } else  if( nrow(t |> dplyr::filter(Var1 ==1 ))  == 1)  {
      t1 <- eval(parse(text= paste0("as.data.frame( prop.table(table( datalist[[\"",
                            rms_indicator[i,1],"\"]]$",
                            rms_indicator[i,2],"))) |>
                            dplyr::filter(Var1 ==1 ) |> dplyr::pull(Freq)"))) } else {
      t1 <- 0}
    compass1 <- as.data.frame(t(c( a = operation,
         b =  population_rms,
         c = "Percent",
         d =  totalBaseline,
         e = round(t1 * 100,2),
         f = round(totalBaseline *t1),
         g = rms_indicator[i,3] )))
    #str(compass)
    #str(compass1)
    compass <- rbind( compass,compass1)
    rm(compass1)
    }

  compass <- compass |>
    as.data.frame() |>
    dplyr::slice(-1) |>
    dplyr::mutate (Plan = a ,
                   `Population Type (operational)` = b ,
                   `Show As` = c,
                   `Baseline Num.` =  f,
                   `Baseline Den.` = d,
                   `%`  = e ,
                   `Indicator` = g)|>
    dplyr::select(Plan,
                  `Indicator`,
                  `Population Type (operational)`,
                  `Show As`,
                  `Baseline Num.`,
                  `Baseline Den.`,
                  `%`  )

  ## And now saving
  ## Create a new workbook
  wb <- openxlsx::createWorkbook()
  ## add the cleaning log to the file
  openxlsx::addWorksheet(wb, "Compass")
  openxlsx::writeData(wb,  "Compass",
                      compass, withFilter = TRUE)
  ## Save workbook
  openxlsx::saveWorkbook(wb,
                         file = here::here(paste0("compass_",
                                                 country,"_",
                                                 stringr::str_replace_all(string=population_rms, pattern=" ", repl=""),
                                                 ".xlsx") ),
                         overwrite = TRUE)
  
  
  ## Now push to RILD 
  if( publish == "yes"){
  p <- riddle::dataset_show(param$ridl)
  list_of_resources <- p[["resources"]][[1]]

  time <- format(Sys.Date(),  '%d%b%y')
  ### Publish the analysis plan ####
  namecompass = paste0("compass_",  country,"_",
                       stringr::str_replace_all(string=population_rms, pattern=" ", repl=""))
  ### Check if the name is already in the resources
  if(namecompass %in% list_of_resources$name) {
        ## get the resource id
        resourceid <- list_of_resources |>
                      dplyr::filter ( name == namecompass) |>
                       dplyr::pull(id)
        ## get the new resource version
        curversion <- list_of_resources |>
          dplyr::filter ( name == namecompass) |>
          dplyr::pull(version)

        ## Build resource metadata
        metadatacompass <- riddle::resource_metadata(
            type = "attachment",
            url = paste0(namecompass, ".xlsx"),
            name = namecompass,
            description = paste0("Compass output generated from RMS on ",  time,
                                 ". Built using kobocruncher "),
            format = "xlsx",
            version = (curversion + 1),
            visibility =  "public",
            file_type = "other",
            ## Revise here based on the name from your crunching report
            upload =  httr::upload_file(here::here(paste0(namecompass, ".xlsx")))
          )
        riddle::resource_update(id = resourceid,
                                res_metadata = metadatacompass)
    } else {

        metadatacompass <- riddle::resource_metadata(
          type = "attachment",
          url = paste0(namecompass, ".xlsx"),
          name = namecompass,
            description = paste0("Compass output generated from RMS on ",  time,
                                 ". Built using kobocruncher "),
          format = "xlsx",
          visibility =  "public",
          file_type = "other",
          ## Revise here based on the name from your crunching report
          upload =  httr::upload_file(here::here(paste0(namecompass, ".xlsx")))
        )
        riddle::resource_create(package_id = p$id,
                                res_metadata = metadatacompass)
    }
  
   }

  return(compass)

}
```
  
```{r example-compass_table}
# compass <- export_compass_fill( country = "ECU",
#                        operation = "Ecuador ABC",
#                        year = 2022,
#                         population_type = c("REF","ASY", "OIP"),
#                         population_rms = "Refugees and Asylum-seekers",
#                         rms_indicator =    rbind(
#   c("main", "impact2_2",  "2.2 Proportion of PoCs residing in physically safe and
#                            secure settlements with access to basic facilities"),
#   c("main", "impact2_3",  "2.3 Proportion of PoC with access to health services"),
#   c("P2.S3", "impact3_2a", "3.2a Proportion of PoC enrolled in primary education" ),
#   c("P2.S3", "impact3_2b",  "3.2b Proportion of PoC enrolled in secondary education" ),
#   c("main", "impact3_3",  "3.3 Proportion of PoC feeling safe walking alone in their neighborhood (related SDG 16.1.4)." ),
#   c("S2", "outcome1_2", "1.2 Proportion of children under 5 years of age whose births
#                    have been registered with a civil authority. [SDG 16.9.1 - Tier 1]" ),
#   c("S2", "outcome1_3", "1.3 Proportion of PoC with legally recognized identity documents or credentials [GCR 4.2.2]." ),
#   c("main", "outcome4_1", "4.1 Proportion of PoC who know where to access available GBV services." ),
#   c("main", "outcome4_2", "4.2 Proportion of POCs who do not accept violence against women." ),
#   c("main", "outcome8_2", "8.2 Proportion of PoC with primary reliance on clean (cooking) fuels and technology [SDG 7.1.2 Tier 1]" ),
#   c("main", "outcome9_1", "9.1 Proportion of PoCs living in habitable and affordable housing." ),
#   c("main", "outcome9_2", "9.2 Proportion of PoC that have energy to ensure lighting (close to Sphere)." ),
#   c("main","outcome12_1", "12.1 Proportion of PoC using at least basic drinking water services (SDG)." ),
# #  c("main" , "outcome12_2", "12.2 Proportion of PoC with access to a safe household toilet (SDG)." ),
#   c("main", "outcome13_1", "13.1. Proportion of PoC with an account at a bank or other
#                               financial institution or with a mobile-money-service provider [SDG 8.10.2 Tier 1]." ),
#   c("main", "outcome13_2", "13.2. Proportion of PoC who self-report positive changes in their income compared to previous year." ),
#   c("main", "outcome13_3",  "13.3 Proportion of PoC (working age) who are unemployed." ),
#   c("main", "outcome16_1", "16.1. Proportion of PoC with secure tenure rights and/or
#     property rights to housing and/or land [revised SDG indicator 1.4.2]." )#,
#  # c("main", "outcome16_2", "16.2. Proportion of PoC covered by social protection floors/systems [SDG 1.3.1]." )
#      ),
#              ridl = params$ridl,
#              publish = params$publish )
```
  
```{r tests-compass_table}
test_that("compass_table works", {
  expect_true(inherits(compass_table, "function")) 
})
```
  
 

 
 

```{r development-inflate, eval=FALSE}
# Keep eval=FALSE to avoid infinite loop in case you hit the knit button
# Execute in the console directly
fusen::inflate(flat_file = "dev/utilities.Rmd", vignette_name = "Utilities")
```

 
