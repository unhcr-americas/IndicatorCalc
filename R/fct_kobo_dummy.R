# WARNING - Generated by {fusen} from dev/utilities.Rmd: do not edit by hand

#' fct_kobo_dummy
#' 
#' @description Automatically produce an dummy dataset in line with the structure 
#' of an XlsForm
#'  Making decisions about research design and analysis strategies is often difficult before data is collected,
#' because it is hard to imagine the exact form data will take.
#' This function helps imagine what data will look like before they collect it.
#' samplesize is set per defautl at 500 records
#'
#'  Supported Features: 
#' - Generate a data set  
#' - respects ODK structure "`relevant`" skip logic
#'    (Some advanced functionality such as "coalesce()" not covered)
#' - respects "`constraint`" 
#' - respects "`repeat`" adds ID column to link hierarchical data based on "`repeat_count`"
#'  This function is a rewriting of
#'     https://unhcr.github.io/koboloadeR/docs/reference/kobo_dummy.html 
#'   it also  build on  https://thinkr-open.github.io/fakir/ and
#'     https://docs.ropensci.org/charlatan/
#' 
#' @param  form file path of the XlsForm
#' @param n number of main records to be generated
#' @param nrepeat max random number of repeat records to be generated 
#'           when repeat_count is not mentionned 
#' @param file file as xlsx where to save the resulting data 
#' 
#' @importFrom kobocruncher kobo_dico
#' 
#' 
#' @return a data list with a series of dummy data 
#' 
#' @export
#' @examples
#' ## generate dummy dataset for different form version
#'
#' ## CAPI
#' form <- system.file("RMS_CAPI_v2.xlsx", package = "IndicatorCalc")
#' datalist <- fct_kobo_dummy(form,
#'                        n = 384,
#'                        file = NULL)
#' # openxlsx::write.xlsx(datalist, here::here("inst", "dummy_RMS_CAPI_v2.xlsx"))
#'
#' form <- system.file("RMS_CAPI_v3.xlsx", package = "IndicatorCalc")
#' datalist <- fct_kobo_dummy(form,
#'                        n = 384,
#'                        file = NULL)
#' # openxlsx::write.xlsx(datalist, here::here("inst", "dummy_RMS_CAPI_v3.xlsx"))
#'
#' ## CATI
#' form <- system.file("RMS_CATI_v0.xlsx", package = "IndicatorCalc")
#' datalist <- fct_kobo_dummy(form,
#'                        n = 384,
#'                        file = NULL)
#' # openxlsx::write.xlsx(datalist, here::here("inst", "dummy_RMS_CATI_v0.xlsx"))
#'
#' form <- system.file("RMS_CATI_v3.xlsx", package = "IndicatorCalc")
#' datalist <- fct_kobo_dummy(form,
#'                        n = 384,
#'                        file = NULL)
#' # openxlsx::write.xlsx(datalist, here::here("inst", "dummy_RMS_CATI_v3.xlsx"))
fct_kobo_dummy <- function(form,
                       n = 384,
                       file){
  
  dico <- kobocruncher::kobo_dico(xlsformpath = form)

  ## Get the variables to extract
  frame <- "main"
  
  conf <- data.frame(
      name <- dico[["variables"]] |>
        dplyr::filter(repeatvar ==  frame)  |> 
        dplyr::filter(! is.na(name))  |> 
        dplyr::filter(!(type %in% c("note", "begin_group", "end_group","begin_repeat", "end_repeat") ))  |> 
        dplyr::select(name),
      
      # dico[["variables"]]|>
      #   dplyr::filter(repeatvar ==  frame)  |> 
      #   dplyr::distinct(type)
      type <- dico[["variables"]]|>
        dplyr::filter(repeatvar ==  frame)  |> 
        dplyr::filter(! is.na(name))  |> 
        dplyr::filter(!(type %in% c("note", "begin_group", "end_group","begin_repeat", "end_repeat") ))  |>
        dplyr::select(type),
      
      ## pulling list options...
      list_opt <- dico[["variables"]] |>
        dplyr::filter(repeatvar ==  frame)  |> 
        dplyr::filter(! is.na(name))  |> 
        dplyr::filter(!(type %in% c("note", "begin_group", "end_group","begin_repeat", "end_repeat") ))  |>
        dplyr::select(list_name) ,
        #dplyr::left_join(modal, by = c("list_name")) |>
      #  dplyr::select( list_opt)
      
      
      constraint <- dico[["variables"]]|>
        dplyr::filter(repeatvar ==  frame)  |> 
        dplyr::filter(! is.na(name))  |> 
        dplyr::filter(!(type %in% c("note", "begin_group", "end_group","begin_repeat", "end_repeat") ))  |>
        dplyr::select(constraint)
  )
  
  ## We start with the generation of the main frame
  ## Build the main table and initiate it an index.....
  main <- dplyr::tibble(
        index = paste0( "ID-",
                      purrr::as_vector(
                            purrr::map(n, sample(LETTERS, 4)) |>
                            purrr::map(paste0, collapse = "")),
                          "-",
                          formatC(1:n, width = nchar(n) + 1, flag = "0")
                        ))
  names(main)[1] <- "_index"
  
  ## then apply fct_var_dummy interactively... 
  for(i in (1:nrow(conf)) ) {
   # i <- 1
    # cat(paste0(i, "-", conf[i, c("type")], "-", conf[i, c("name")],  "\n"))
  
  ## manage specific case when list name is not defined in ccoices but pulled from data..
  ## in such case we replace type by select_one by text
  this.type <-  conf[i, c("type")]
  this.name <-  conf[i, c("name")]
  this.listname <- conf[i , c("list_name")]
  this.constraint =  conf[i, c("constraint")] 
  
  ## cas there's no list matching..
  if( this.type %in% c("select_one", "select_multiple") & 
      !(this.listname %in% c( dico[["modalities"]] |> 
                              dplyr::pull(list_name))) ) { 
     this.listname <- NULL
     this.type <- "text"
     }
   
   main <- fct_var_dummy( 
          frame = main,
          name = this.name,
          type = this.type,
          list_opt =  c(dico[["modalities"]] |>
                         dplyr::filter(list_name == this.listname   )  |>
                         dplyr::pull(name) ),
          constraint =  this.constraint )
  }
    
  ## Still struggling with purrr
  # test  <- purrr::map(  main,
  #                       name,
  #                       type,
  #                       list_opt$list_opt ,
  #                       constraint ,
  #                     fct_var_dummy)
  
  ## TODO -- apply the relevance statement...
  ## define when the variable should exist based on other elements
  ## Need to convert the xlsform statement into R syntax
  # relevant <- dico[["variables"]]|>
  #   dplyr::filter(repeatvar == "main")  |> 
  #   dplyr::pull(relevant)
  
  ## replace  \" by ' 
  ## replace '=' by '=="
  ## replace '!==' by '!=" (to fix previsous replace)
  ## replace '${' '}'  with nothing..
  ## replace 'or'  with  '|'..
  ## replace 'and'  with '&'..
  
  ## Now store in the list...
  datalist <- list ( "main" = main) 

  ## treat cases with repeat table.. #####
  repeatvar <- dico[["variables"]] |> 
    dplyr::select(repeatvar)  |>
    dplyr::filter(repeatvar != "main")  |>
    dplyr::distinct()   |>
    dplyr::pull()   
  ## need to separate the different repeat elements wthin the form...
  for ( rep in repeatvar ) {
        
               confrep <- data.frame(
                    name <- dico[["variables"]] |>
                      dplyr::filter(repeatvar ==  rep)  |>  
                      dplyr::filter(! is.na(name))  |> 
                      dplyr::filter(!(type %in% c("note", "begin_group",
                                                  "end_group","begin_repeat", "end_repeat") ))  |>
                      dplyr::select(name),
                    
                    # dico[["variables"]]|>
                    #   dplyr::filter(repeatvar ==  rep)  |> 
                    #   dplyr::distinct(type)
                    type <- dico[["variables"]]|>
                      dplyr::filter(repeatvar ==  rep)  |> 
                      dplyr::filter(! is.na(name))  |> 
                      dplyr::filter(!(type %in% c("note", "begin_group",
                                                  "end_group","begin_repeat", "end_repeat") ))  |>
                      dplyr::select(type),
                    
                    ## pulling list options...
                    list_opt <- dico[["variables"]] |>
                      dplyr::filter(repeatvar ==  rep)  |> 
                      dplyr::filter(! is.na(name))  |> 
                      dplyr::filter(!(type %in% c("note", "begin_group",
                                                  "end_group","begin_repeat", "end_repeat") ))  |>
                      dplyr::select(list_name) ,
                      #dplyr::left_join(modal, by = c("list_name")) |>
                    #  dplyr::select( list_opt)
                    
                    
                    constraint <- dico[["variables"]]|>
                      dplyr::filter(repeatvar ==  rep)  |> 
                      dplyr::filter(! is.na(name))  |> 
                      dplyr::filter(!(type %in% c("note", "begin_group",
                                                  "end_group","begin_repeat", "end_repeat") ))  |>
                      dplyr::select(constraint)
                  )
            
            ## We start with the generation of the main frame
            ## Build the main table and initiate it an index.....
            repframe <- dplyr::tibble(
                  index = paste0( "ID-",
                                purrr::as_vector(
                                      purrr::map(n, sample(LETTERS, 4)) |>
                                      purrr::map(paste0, collapse = "")),
                                    "-",
                                    formatC(1:n, width = nchar(n) + 1, flag = "0")
                                  ))
            
            names(repframe)[1] <- "_parent_index"
            ## Apply now `_index`
            ## TODO -- check if we have a `repeat_count` to apply limitation..
            
            ## then apply fct_var_dummy interactively... 
            for(i in (1:nrow(confrep)) ) {
             # i <- 6
            #  cat(paste0(i, " in repeat -", rep, " ///", confrep[i, c("type")], "-", confrep[i, c("name")],  "\n"))
            
            ## manage specific case when list name is not defined in ccoices but pulled from data..
            ## in such case we replace type by select_one by text
            this.type <-  confrep[i, c("type")]
            this.name <-  confrep[i, c("name")]
            this.listname <- confrep[i , c("list_name")]
            this.constraint =  confrep[i, c("constraint")] 
            
            if(this.type %in% c("select_one", "select_multiple") & 
              !(this.listname %in% c( dico[["modalities"]] |>  
                                      dplyr::pull(list_name))) ) { 
               this.listname <- NULL
               this.type <- "text"
               }
             
             repframe <- fct_var_dummy( 
                    frame = repframe,
                    name = this.name,
                    type = this.type,
                    list_opt =  c(dico[["modalities"]] |>
                                   dplyr::filter(list_name == this.listname   )  |>
                                   dplyr::pull(name) ),
                    constraint =  this.constraint )
            }
        ## append to the repeat
        datalist[[rep]] <- repframe
      }
  return(datalist)
  }
